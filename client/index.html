<!doctype html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>MoneyTron ‚Äî Multi-User Money Tracker</title>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

  <!-- React + Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

  <!-- Day.js + XLSX -->
  <script src="https://unpkg.com/dayjs@1/dayjs.min.js"></script>
  <script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/dayjs@1/plugin/customParseFormat.js"></script>
  <script>
    dayjs.extend(window.dayjs_plugin_customParseFormat);
  </script>

  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>

  <style>
    :root{
      --ink:#2b2f42;
      --muted:#667085;
      --brand:#6b46c1;
      --card:#ffffff;
      --chipBlue:#dbeafe; --chipBlueText:#1e40af;
      --yellowBg:#fff7ed; --yellowBorder:#fcd19c; --yellowText:#92400e;
      --dangerRow:#fee2e2;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial,"Noto Sans";
      color:var(--ink);
      background: radial-gradient(1200px 700px at 80% 20%, #8b5cf6 0%, #6d28d9 55%, #5b21b6 100%);
      background-attachment: fixed;
      overflow-x: hidden;
    }
    .wrap{ width:min(1280px,96vw); margin:24px auto; padding:24px; }
    .title{ font-size:44px; font-weight:800; margin:0 0 16px; text-align:center; color:#eae9ff; text-shadow:0 2px 18px rgba(0,0,0,.35); }
    .frame{ background:rgba(255,255,255,.88); backdrop-filter: blur(6px); border-radius:18px; padding:16px; margin-top:12px; }
    .panel{ background:var(--card); border-radius:16px; padding:20px 24px; box-shadow:0 10px 20px rgb(8 24 71 / 8%); max-width:100%; overflow:auto; }

    .topbar{ display:flex; gap:12px; justify-content:center; align-items:center; margin-bottom:14px; }
    .pill{ border:none; border-radius:999px; padding:10px 16px; background:linear-gradient(180deg,#7c3aed,#6d28d9); color:#fff; font-weight:700; box-shadow:0 6px 14px rgba(91,33,182,.35); transition:transform .12s, box-shadow .12s; }
    .pill:hover{ transform:translateY(-1px); box-shadow:0 8px 18px rgba(91,33,182,.35); }
    .pill.welcome{ cursor:default; box-shadow:none; }
    .pill.welcome:hover{ transform:none; box-shadow:none; }
    .ghost{ background:#eef2ff; color:#3949ab; box-shadow:none; font-weight:600; }
    .ghost:hover{ filter:brightness(.98); transform:translateY(-1px); }

    .tabs{ display:flex; gap:14px; justify-content:center; flex-wrap:wrap; margin:10px 0 18px; }
    .tab{ position:relative; overflow:hidden; border:none; border-radius:999px; padding:10px 18px; background:#f2f3ff; color:#3d2c7a; font-weight:700; box-shadow:inset 0 0 0 1px #ecebff; transition:all .2s; }
    .tab:hover{ transform:translateY(-1px); box-shadow:0 6px 12px rgba(91,33,182,.12); }
    .tab.active{ background:linear-gradient(180deg,#7c3aed,#6d28d9); color:#fff; box-shadow:0 6px 14px rgba(91,33,182,.35); }
    .tab::after{ content:""; position:absolute; top:0; left:-120%; width:60%; height:100%;
      background:linear-gradient(120deg, rgba(255,255,255,0) 0%, rgba(255,255,255,.7) 48%, rgba(255,255,255,0) 100%);
      transform:skewX(-25deg); transition:left .35s; pointer-events:none; }
    .tab:hover::after{ left:160%; }

    .section-title{ display:flex; align-items:center; gap:10px; font-size:24px; font-weight:800; margin:8px 0 6px; color:#30334b; }
    .section-sub{ color:#667085; font-size:14px; margin:0 0 12px; }
    .thin-underline{ height:2px; background:linear-gradient(90deg,#7c3aed,#6d28d9); border-radius:999px; width:100%; margin:4px 0 10px; opacity:.55; }

    .kpis{ display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:14px; margin:10px 0 16px; }
    .kpi{ border-radius:16px; padding:16px; color:#fff; font-weight:800; text-align:center; }
    .k1{ background:linear-gradient(180deg,#6a38c2,#4b2aa9); }
    .k2{ background:linear-gradient(180deg,#15978a,#0d7662); }
    .k3{ background:linear-gradient(180deg,#e6762c,#b85916); }
    .k4{ background:linear-gradient(180deg,#d23a52,#aa2340); }
    .kpi .n{ font-size:28px; display:block; margin-top:2px; }

    .controls{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .btn{ border:none; border-radius:12px; padding:10px 14px; font-weight:700; background:#ecebff; color:#352b7a; transition:transform .12s, box-shadow .12s, filter .12s; }
    .btn:hover{ transform:translateY(-1px); filter:brightness(.98); box-shadow:0 6px 14px rgba(91,33,182,.12); }
    .btn.primary{ background:linear-gradient(180deg,#7c3aed,#6d28d9); color:#fff; box-shadow:0 6px 14px rgba(91,33,182,.35); }
    .btn.danger{ background:#fee2e2; color:#991b1b; }
    .btn[disabled]{ opacity:.55; cursor:not-allowed; box-shadow:none; filter:grayscale(.1); }

    table{ width:100%; border-collapse:separate; border-spacing:0 8px; }
    thead th{ font-size:13px; letter-spacing:.3px; font-weight:800; color:#f2f1ff;
      background:linear-gradient(180deg,#6b46c1,#49308d); padding:10px 12px; user-select:none; cursor:pointer; }
    thead th.nosort{ cursor:default; }
    tbody td{ background:#fff; padding:10px 12px; color:#2d2f44; box-shadow:0 2px 6px rgba(16,24,40,.08); vertical-align:middle; text-align:center; }
    tbody tr td:first-child{ border-radius:10px 0 0 10px; text-align:left; }
    tbody tr td:last-child{ border-radius:0 10px 10px 0; }
    .row-vi td{ background:var(--dangerRow)!important; color:#7f1d1d; }

    input[type="text"], input[type="number"], select{ width:100%; padding:8px 10px; border-radius:10px; border:1px solid #e5e7eb; background:#fff; font-family:inherit; font-size:14px; text-align:center; }
    .locked{ background:#f9fafb; }
    .type-pill{ border:none; border-radius:999px; padding:8px 14px; font-weight:800; cursor:pointer; box-shadow:0 3px 10px rgba(0,0,0,.08); }
    .type-exp{ background:#fee2e2; color:#991b1b; }
    .type-inc{ background:#dcfce7; color:#065f46; }
    .currency-toggle{ border:none; border-radius:10px; padding:6px 8px; margin-right:6px; font-weight:800; background:#eef2ff; color:#352b7a; cursor:pointer; }

    .toolbar{ display:grid; grid-template-columns:1fr auto 1fr; gap:12px; align-items:center; }
    .toolbar .left{ display:flex; gap:8px; align-items:center; }
    .toolbar .middle{ display:flex; flex-direction:column; align-items:center; }
    .toolbar .right{ display:flex; gap:8px; justify-content:flex-end; align-items:center; }
    .input-xs{ padding:8px 10px; font-size:14px; min-width:220px; }
    .btn-xs{ padding:8px 12px; font-size:14px; border-radius:999px; }

    .badge{ display:inline-flex; align-items:center; padding:4px 10px; border-radius:999px; background:#ede9fe; color:#5b21b6; font-weight:800; font-size:12px; }
    .cat-grid{ display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:14px; }
    @media (max-width:900px){ .cat-grid{ grid-template-columns:1fr; } }
    .cat-card{ border-radius:16px; padding:14px; background:#fff; box-shadow:0 8px 16px rgba(16,24,40,.08); }
    .cat-head{ display:flex; align-items:center; gap:10px; margin-bottom:10px; }
    .cat-name{ font-weight:800; font-size:18px; color:#2c2761; }
    .chip{ display:inline-flex; align-items:center; gap:6px; background:var(--chipBlue); color:var(--chipBlueText); border-radius:999px; padding:6px 10px; font-weight:700; margin:4px; }
    .chip a{ color:#991b1b; text-decoration:none; }

    .muted{ color:#667085; font-size:13px; }
    .grid-2{ display:grid; grid-template-columns:1fr 1fr; gap:14px; }
    @media (max-width:1000px){ .grid-2{ grid-template-columns:1fr; } }

    .chart-box{ position:relative; width:100%; height:340px; }

    .dm-grid{ display:grid; grid-template-columns:1fr auto; gap:16px; align-items:flex-start; }
    .dm-left{ display:flex; gap:12px; flex-wrap:wrap; }
    .dm-right{ display:flex; flex-direction:column; align-items:flex-end; gap:8px; }
    @media (max-width:700px){ .dm-grid{ grid-template-columns:1fr; } .dm-right{ align-items:flex-start; } }
    .danger-caption{ display:inline-flex; align-items:center; gap:8px; color:#b45309; background:#fff7ed; border:1px dashed #fcd19c; border-radius:10px; padding:8px 10px; font-weight:700; width:max-content; }

    .w-tag{ width:75px; min-width:75px; }
    .w-date{ min-width:160px; }
    .w-name{ min-width:150px; max-width:180px; }
    .cell-hscroll{ max-width:180px; margin:0 auto; overflow-x:hidden; white-space:nowrap; }
    .cell-hscroll:hover{ overflow-x:auto; }
    .ro-name{ display:inline-block; padding:8px 10px; }
    input.fit{ width:max-content; text-align:center; }
    .w-amt{ min-width:150px; }
    .w-debit{ min-width:150px; }
    .num-input{ width:120px; }
    .w-cat{ min-width:132px; }
    .w-sub{ min-width:150px; }
    .w-notes{ min-width:240px; }
    .ro-tag{ display:inline-block; min-width:40px; padding:6px 10px; border-radius:10px; background:#eef2ff; color:#352b7a; font-weight:800; text-align:center; }
  </style>
</head>
<body>
  <div id="root" class="wrap"></div>

  <script type="text/babel" data-presets="react">
const MT_DEBUG = true;
function fmt2(n){ n=Number(n); if(!isFinite(n)) return '0.00'; return n.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2}); }

// Format date as DD-MM-YYYY consistently everywhere
function formatDMY(dateInput) {
  if (!dateInput) return '';
  let d;
  
  // Handle various input formats
  if (typeof dateInput === 'string') {
    // If already in DD-MM-YYYY format, return as-is
    if (/^\d{2}-\d{2}-\d{4}$/.test(dateInput)) {
      return dateInput;
    }
    // Parse ISO format YYYY-MM-DD to DD-MM-YYYY
    if (/^\d{4}-\d{2}-\d{2}$/.test(dateInput)) {
      const [y, m, day] = dateInput.split('-');
      return `${day}-${m}-${y}`;
    }
    // Try parsing with dayjs
    d = dayjs(dateInput);
  } else if (dateInput instanceof Date) {
    d = dayjs(dateInput);
  } else {
    d = dayjs(dateInput);
  }
  
  if (d && d.isValid()) {
    return d.format('DD-MM-YYYY');
  }
  return String(dateInput);
}

// Parse DD-MM-YYYY to ISO YYYY-MM-DD for storage
function parseDMYtoISO(dmyStr) {
  if (!dmyStr) return '';
  const match = String(dmyStr).match(/^(\d{2})-(\d{2})-(\d{4})$/);
  if (match) {
    const [, day, month, year] = match;
    return `${year}-${month}-${day}`;
  }
  // Try to parse with dayjs if not in DD-MM-YYYY format
  const d = dayjs(dmyStr, 'DD-MM-YYYY', true);
  if (d.isValid()) {
    return d.format('YYYY-MM-DD');
  }
  return dmyStr;
}

var API=(function(){
  var base='/api';
  function j(r){ if(!r.ok) throw new Error('HTTP '+r.status); return r.json(); }
  function f(m,u,b){ var o={method:m,credentials:'include',headers:{}}; if(b){o.headers['Content-Type']='application/json';o.body=JSON.stringify(b);} return fetch(base+u,o); }
  return {
    users:()=>f('GET','/users').then(j),
    login:(user)=>f('POST','/login',{user}).then(j),
    current:()=>f('GET','/current-user').then(j),
    bootstrap:()=>f('GET','/bootstrap').then(j),
    logout:()=>f('POST','/logout').then(j),
    getCategories:()=>f('GET','/categories').then(j),
    saveCategories:(c)=>f('POST','/categories',{categories:c}).then(j),
    getStage:()=>f('GET','/current-month').then(j),
    saveStage:(rows)=>f('POST','/current-month',{transactions:rows}).then(j),
    getPast:()=>f('GET','/past-data').then(j),
    savePast:(rows)=>f('POST','/past-data',{past_data:rows}).then(j),
    saveTransactions:(rows)=>f('POST','/transactions',{transactions:rows}).then(j),
    getSettings:()=>f('GET','/settings').then(j),
    saveSettings:(settings)=>f('POST','/settings',{settings}).then(j),
    importData:(payload)=>f('POST','/import',payload).then(j),
    clearAll:()=>f('POST','/clear-all').then(j),
    // Statistics endpoints
    statsSummary:(filters)=>f('POST','/statistics/summary',filters).then(j),
    statsPerTagMeans:(filters)=>f('POST','/statistics/per_tag_means',filters).then(j),
    statsCategoryLast3:(filters)=>f('POST','/statistics/category_last3_mean',filters).then(j),
    statsIncomeMeans:(filters)=>f('POST','/statistics/income_means',filters).then(j),
    statsRollup:(filters)=>f('POST','/statistics/rollup',filters).then(j),
  };
})();

function asArray(x){ if(Array.isArray(x)) return x; if(x && Array.isArray(x.items)) return x.items; if(x && Array.isArray(x.data)) return x.data; return []; }
function asCategories(x){ if(x && typeof x==='object' && !Array.isArray(x)) return x; if(Array.isArray(x)){var o={}; x.forEach(it=>{ if(typeof it==='string') o[it]=[]; else if(it && it.name) o[it.name]=Array.isArray(it.subcategories)?it.subcategories.slice():[]; }); return o;} return {}; }

/* ================== File parsing (v7) ================== */
function bestNameFromRow_v6(row, avoidCols){
  const avoid = new Set((avoidCols||[]).filter(x=>x!=null));
  let best = {text:'', score:-1};
  for (let c=0;c<row.length;c++){
    if (avoid.has(c)) continue;
    const raw = row[c];
    if (raw==null) continue;
    const s = String(raw).trim();
    if (!s) continue;
    if (parseDateFlex_v6(raw)) continue;
    if (!/[A-Za-z\u0590-\u05FF]/.test(s)) continue;
    if (!isNaN(Number(s.replace(/[,\s‚Ç™$‚Ç¨¬£]/g,'')))) continue;
    const score = s.length;
    if (score > best.score) best = {text:s, score};
  }
  return best.text || '';
}
function parseAmount(v){
  if (v == null || v === '') return 0;
  let s = String(v).trim();
  let neg = false;
  if (/^\(.*\)$/.test(s)) { neg = true; s = s.slice(1,-1); }
  if (/[-‚àí‚Äì-]\s*$/.test(s)) { neg = true; s = s.replace(/[-‚àí‚Äì-]\s*$/,''); }
  s = s.replace(/[‚Ç™$‚Ç¨¬£]/g,'').replace(/\u200f|\u200e/g,'').replace(/\s+/g,'');
  if (s.includes('.') && s.includes(',')) s = s.replace(/\./g,'').replace(',', '.'); else s = s.replace(/,/g,'');
  s = s.replace(/[^0-9.\-]/g,'');
  let n = Number(s); if (!isFinite(n)) n = 0;
  return neg ? -Math.abs(n) : n;
}

/* ---------- helpers ---------- */
function exactLocalDate_v6(y,m,d){ return new Date(y, m-1, d, 12, 0, 0); }
function excelSerialToDate_v6(n){
  try{
    var o = XLSX.SSF.parse_date_code(Number(n));
    if (o && o.y && o.m && o.d){ return exactLocalDate_v6(o.y, o.m, o.d); }
  }catch(_){}
  var days = Math.floor(Number(n));
  var base = Date.UTC(1899,11,30);
  var dt = new Date(base + days*86400000);
  return exactLocalDate_v6(dt.getUTCFullYear(), dt.getUTCMonth()+1, dt.getUTCDate());
}
function isLikelyExcelSerial_v6(n){ var x=Number(n); return Number.isFinite(x) && x>20000 && x<50000; }
function normHeb_v6(s){ return String(s||'').replace(/\s+/g,'').toLowerCase(); }
// Robust header normalization: keep only Hebrew/Latin letters (drop punctuation, quotes, slashes, spaces)
function normAZ(s){
  return String(s||'').toLowerCase().replace(/[^a-z\u0590-\u05FF]/g,'');
}
function numify_v6(v){
  if (v==null || v==='') return null;
  if (typeof v==='number' && Number.isFinite(v)) return v;
  let s = String(v).trim();
  if (!s) return null;
  // normalize spaces and RTL marks
  s = s.replace(/\u00a0/g,'').replace(/\u200f|\u200e/g,'');
  let neg = false;
  // (123) style
  if (/^\(.*\)$/.test(s)) { neg = true; s = s.slice(1,-1); }
  // trailing minus 123- or 123 ‚àí
  if (/[-‚àí‚Äì-]\s*$/.test(s)) { neg = true; s = s.replace(/[-‚àí‚Äì-]\s*$/,''); }
  // strip currency and spaces
  s = s.replace(/[‚Ç™$‚Ç¨¬£]/g,'').replace(/\s+/g,'');
  // handle thousand/decimal separators
  if (s.includes('.') && s.includes(',')) {
    s = s.replace(/\./g,'').replace(',', '.');
  } else {
    s = s.replace(/,/g,'');
  }
  // keep only digits and dot/minus
  s = s.replace(/[^0-9.\-]/g,'');
  let n = Number(s);
  if (!Number.isFinite(n)) return null;
  return neg ? -Math.abs(n) : n;
}
function isText_v6(v){
  if (v==null) return false;
  var s=String(v).trim(); if (!s) return false;
  return isNaN(Number(s.replace(/[,‚Ç™$‚Ç¨¬£]/g,'')));
}

/* ---------- STRICT date parsing ---------- */
function parseDateFlex_v6(v){
  if (v==null || v==='') return null;
  if (v instanceof Date && !isNaN(v)) return exactLocalDate_v6(v.getFullYear(), v.getMonth()+1, v.getDate());
  if (typeof v==='number' && isLikelyExcelSerial_v6(v)) return excelSerialToDate_v6(v);

  // normalize string: remove RTL/LRM/embedding marks + NBSP
  let s = String(v).trim();
  if (!s) return null;
  s = s.replace(/[\u200f\u200e\u202a\u202b\u202c\u2066\u2067\u2068\u2069\u00a0]/g, '');

  // pull a date-like token if the cell has extra text around it
  const token = s.match(/(\d{1,2}[\/.\-]\d{1,2}(?:[\/.\-]\d{2,4})?|\d{4}[\/.\-]\d{1,2}[\/.\-]\d{1,2}|[A-Za-z]{3,9}\s+\d{1,2},?\s+\d{4}|\d{1,2}\s+[A-Za-z]{3,9}\s+\d{4})/);
  if (token) s = token[1].replace(/[.]/g,'/');

  const today = new Date();
  const assumeY = today.getFullYear();

  const fmtsDayFirst = ['D/M/YYYY','DD/MM/YYYY','D/M/YY','DD/MM/YY','D-M-YYYY','DD-MM-YYYY','D/M','DD/MM','D-M','DD-MM'];
  for (let f of fmtsDayFirst){
    const d=dayjs(s,f,true);
    if (d.isValid()){
      const y = d.year() < 1900 ? assumeY : d.year();
      return exactLocalDate_v6(y, d.month()+1, d.date());
    }
  }
  const fmtsYearFirst = ['YYYY/M/D','YYYY/MM/DD','YYYY-M-D','YYYY-MM-DD'];
  for (let f of fmtsYearFirst){
    const d=dayjs(s,f,true);
    if (d.isValid() && d.year()>1899 && d.year()<2101) return exactLocalDate_v6(d.year(), d.month()+1, d.date());
  }
  const fmtsMonText = ['D MMM YYYY','DD MMM YYYY','MMM D YYYY','MMM DD YYYY'];
  for (let f of fmtsMonText){
    const d=dayjs(s,f,true);
    if (d.isValid() && d.year()>1899 && d.year()<2101) return exactLocalDate_v6(d.year(), d.month()+1, d.date());
  }
  return null;
}

/* ---------- header finders ---------- */
function isBalanceLabel_v6(lbl){
  const n = normHeb_v6(lbl||'');
  return /(◊ô◊™◊®◊î|balance|saldo|◊ô◊™◊®◊™◊ó◊©◊ë◊ï◊ü|◊ô◊™◊®◊î◊§◊™◊ô◊ó◊î|◊ô◊™◊®◊î◊°◊ï◊§◊ô◊™)/.test(n);
}
function mapFromHeaderRow_v6(matrix, r){
  var row = matrix[r]||[];
  var norm = row.map(normAZ); // letters-only normalization for robust matching
  function idx(pred){ for (var i=0;i<norm.length;i++){ if (pred(norm[i], i)) return i; } return -1; }

    // Prefer exact Leumi "◊™◊ê◊®◊ô◊ö ◊î◊¢◊°◊ß◊î" (note: normAZ removes spaces -> '◊™◊ê◊®◊ô◊ö◊î◊¢◊°◊ß◊î')
    let dateCol  = idx(x=>x.includes('◊™◊ê◊®◊ô◊ö◊î◊¢◊°◊ß◊î') || x === '◊™◊ê◊®◊ô◊ö');
    if (dateCol < 0) dateCol = idx(x=>x.includes('◊™◊ê◊®◊ô◊ö') || x.includes('date'));

  // NAME / DESCRIPTION column (loose)
  let   nameCol  = idx(x=>
      x.includes('◊©◊ù◊ë◊ô◊™◊¢◊°◊ß')||x.includes('◊©◊ù◊¢◊°◊ß')|| (x.includes('◊©◊ù') && x.includes('◊¢◊°◊ß')) ||
      x.includes('◊™◊ô◊ê◊ï◊®')||x.includes('◊§◊®◊ò◊ô◊ù')||x.includes('◊™◊ô◊ê◊ï◊®◊§◊¢◊ï◊ú◊î')||x.includes('◊§◊®◊ò◊ô◊™◊†◊ï◊¢◊î')||x.includes('◊§◊ô◊®◊ï◊ò')||
      x.includes('description')
  );
  const hCol     = idx(x=>x==='◊ó◊ï◊ë◊î');
  const zCol     = idx(x=>x==='◊ñ◊õ◊ï◊™');

  let debitCol = idx(x=> (x.includes('◊°◊õ◊ï◊ù◊ó◊ô◊ï◊ë')||x.includes('◊ú◊™◊©◊ú◊ï◊ù')||x.includes('◊ú◊ó◊ô◊ï◊ë')||x.includes('◊ë◊©◊ó')) && !isBalanceLabel_v6(x));
  let transCol = idx(x=> (x.includes('◊°◊õ◊ï◊ù◊¢◊°◊ß◊î')||x.includes('amount')) && !isBalanceLabel_v6(x));

  if (nameCol < 0){
    const COLS = row.length;
    let best = {c:-1,score:-1};
    for (let c=0;c<COLS;c++){
      if (c===dateCol) continue;
      let textHits=0, dateHits=0, lenSum=0;
      for (let rr=r+1; rr<Math.min(matrix.length, r+200); rr++){
        const v=(matrix[rr]||[])[c];
        if (v==null) continue;
        const s=String(v).trim();
        if (!s) continue;
        if (parseDateFlex_v6(v)) { dateHits++; continue; }
        if (/[A-Za-z\u0590-\u05FF]/.test(s) && isNaN(Number(s.replace(/[\,\s]/g,'')))) { textHits++; lenSum+=s.length; }
      }
      const score = textHits*2 + lenSum*0.05 - dateHits*4;
      if (score>best.score) best={c,score};
    }
    nameCol = best.c;
  }

  return {row:r, dateCol, nameCol, transCol:(transCol>=0?transCol:null), debitCol:(debitCol>=0?debitCol:null), hCol:(hCol>=0?hCol:null), zCol:(zCol>=0?zCol:null)};
}
function findHeaderRows_v6(matrix){
  var rows=[];
  for (var r=0;r<matrix.length;r++){
    var norm=(matrix[r]||[]).map(normAZ);
    var hasDate=norm.some(x=>x.includes('◊™◊ê◊®◊ô◊ö')||x.includes('date'));
    var hasName=norm.some(x=>x.includes('◊©◊ù◊ë◊ô◊™◊¢◊°◊ß')||x.includes('◊©◊ù◊¢◊°◊ß')||(x.includes('◊©◊ù')&&x.includes('◊¢◊°◊ß'))||x.includes('◊™◊ô◊ê◊ï◊®')||x.includes('◊§◊®◊ò◊ô◊ù')||x.includes('◊™◊ô◊ê◊ï◊®◊§◊¢◊ï◊ú◊î')||x.includes('◊§◊®◊ò◊ô◊™◊†◊ï◊¢◊î')||x.includes('◊§◊ô◊®◊ï◊ò'));
    var hasTxn = norm.some(x =>
    x.includes('◊°◊õ◊ï◊ù◊î◊¢◊°◊ß◊î') || x.includes('◊°◊õ◊ï◊ù◊¢◊°◊ß◊î') || (x.includes('◊¢◊°◊ß◊î') && x.includes('◊°◊õ◊ï◊ù'))
    );
    var hasDeb = norm.some(x =>
    x.includes('◊°◊õ◊ï◊ù◊î◊ó◊ô◊ï◊ë') || x.includes('◊°◊õ◊ï◊ù◊ó◊ô◊ï◊ë') || x.includes('◊ú◊™◊©◊ú◊ï◊ù') || x.includes('◊ú◊ó◊ô◊ï◊ë') || x.includes('◊ë◊©◊ó')
    );
    if (hasDate && (hasName || hasTxn || hasDeb)) rows.push(r);
  }
  return rows;
}
function detectHeuristic_v6(matrix){
  var rows=matrix.length, cols=0;
  for (var r=0;r<rows;r++){ if ((matrix[r]||[]).length>cols) cols=(matrix[r]||[]).length; }
  if (!cols) return null;
  var dateScore=new Array(cols).fill(0), textScore=new Array(cols).fill(0);
  for (var r=0;r<rows;r++){
    var row=matrix[r]||[];
    for (var c=0;c<cols;c++){
      var v=row[c];
      if (parseDateFlex_v6(v)) dateScore[c]++;
      if (isText_v6(v)) textScore[c]++;
    }
  }
  var dateCol=0, maxD=-1;
  for (var c=0;c<cols;c++){ if (dateScore[c]>maxD){ maxD=dateScore[c]; dateCol=c; } }
  var nameCol=-1, maxT=-1;
  for (var c=0;c<cols;c++){ if (c===dateCol) continue; if (textScore[c]>maxT){ maxT=textScore[c]; nameCol=c; } }

  var txRows=[];
  for (var r=0;r<rows;r++){
    var d=parseDateFlex_v6((matrix[r]||[])[dateCol]);
    var n=(matrix[r]||[])[nameCol]; var nt=String(n==null?'':n).trim();
    if (d && nt && isNaN(Number(nt))) txRows.push(r);
  }
  var cand=[];
  for (var c=0;c<cols;c++){
    if (c===dateCol || c===nameCol) continue;
    var num=0, dec=0;
    for (var i=0;i<txRows.length;i++){
      var r=txRows[i];
      var v=(matrix[r]||[])[c]; if (v==null || String(v).trim()==='') continue;
      var n=numify_v6(v); if (n==null) continue;
      num++; if (Math.round(n)!==n) dec++;
    }
    if (!num) continue;
    cand.push({ci:c, score:num + (dec/num)*2});
  }
  cand.sort(function(a,b){ return (b.score===a.score)? (b.ci-a.ci) : (b.score-a.score); });
  var left = cand.length? Math.min(cand[0].ci, (cand[1]||cand[0]).ci): null;
  var right= cand.length? Math.max(cand[0].ci, (cand[1]||cand[0]).ci): null;
  return {dateCol:dateCol, nameCol:nameCol, transCol:left, debitCol:right};
}

/* ---------- SHEET extractor (v7) ---------- */
/* ---------- SHEET extractor v7 (carry-forward date for merged rows) ---------- */
function extractFromSheet_v6(ws, sheetName){
  const mat = XLSX.utils.sheet_to_json(ws,{header:1,raw:true,defval:null});
  const rows = [];

  function toISO(d){
    if (d instanceof Date) return dayjs(d).format('YYYY-MM-DD');
    if (typeof d==='string'){ const dd=parseDateFlex_v6(d); if (dd) return dayjs(dd).format('YYYY-MM-DD'); }
    if (typeof d==='number' && isLikelyExcelSerial_v6(d)) return dayjs(excelSerialToDate_v6(d)).format('YYYY-MM-DD');
    return null;
  }

  function pushRow(dateObj,name,t,db,creditByHZ){
    const iso = toISO(dateObj);
    const nameStr = String(name||'').trim();
    const tNum  = (t==null ? null : Number(t));
    const dbNum = (db==null ? null : Number(db));
    const base  = (dbNum!=null && dbNum!==0) ? dbNum : (tNum!=null ? tNum : 0);
    if (!iso || !nameStr || !base) return;
    const credit = creditByHZ != null ? creditByHZ : ((tNum!=null && tNum<0) || (dbNum!=null && dbNum<0));
    
    // Extract year and month_tag from ISO date - ISO is always YYYY-MM-DD
    const [isoYearStr, isoMonthStr, isoDayStr] = iso.split('-');
    let year = parseInt(isoYearStr);
    let month_tag = parseInt(isoMonthStr);
    let dayNum = parseInt(isoDayStr);
    
    // CRITICAL FIX: Check if we need to swap day and month
    // If the file has a consistent tag (month), and the parsed month doesn't match,
    // it means Excel/parser interpreted DD/MM as MM/DD - we need to swap!
    // We allow a small tolerance for cross-month transactions (¬±1 month)
    const userTag = window.__currentUploadTag;  // Set during upload
    if (userTag && Math.abs(month_tag - userTag) > 1 && dayNum >= 1 && dayNum <= 12) {
      // Month doesn't match tag, and day is valid as a month (1-12), so swap them
      [month_tag, dayNum] = [dayNum, month_tag];
      year = parseInt(isoYearStr);  // Keep year the same
    }
    
    // CRITICAL: Always format as DD-MM-YYYY (day first!)
    const date_str = `${String(dayNum).padStart(2,'0')}-${String(month_tag).padStart(2,'0')}-${year}`;
    
    // Reconstruct ISO with corrected values
    const corrected_iso = `${year}-${String(month_tag).padStart(2,'0')}-${String(dayNum).padStart(2,'0')}`;
    
    rows.push({
      date: corrected_iso,           // ISO format for storage
      date_iso: corrected_iso,       // Explicit ISO column
      date_str: date_str,  // DD-MM-YYYY format
      year: year,
      month_tag: month_tag,
      tag: month_tag,      // Keep legacy tag field for compatibility
      name: nameStr,
      amount: Math.abs(tNum!=null ? tNum : base),
      debit:  Math.abs(dbNum!=null ? dbNum : base),
      __credit: !!credit
    });
  }

  // quick header detector
  function isHeaderRow(row){
    const n = (row||[]).map(normAZ);
    const hasDate = n.some(x => x.includes('◊™◊ê◊®◊ô◊ö') || x.includes('date'));
    const hasName = n.some(x =>
      x.includes('◊©◊ù◊ë◊ô◊™◊¢◊°◊ß') || x.includes('◊©◊ù◊¢◊°◊ß') || (x.includes('◊©◊ù') && x.includes('◊¢◊°◊ß')) ||
      x.includes('◊™◊ô◊ê◊ï◊®') || x.includes('◊§◊®◊ò◊ô◊ù') || x.includes('◊™◊ô◊ê◊ï◊®◊§◊¢◊ï◊ú◊î') ||
      x.includes('◊§◊®◊ò◊ô◊™◊†◊ï◊¢◊î') || x.includes('◊§◊ô◊®◊ï◊ò') || x.includes('description')
    );
    const hasTxn  = n.some(x => x.includes('◊°◊õ◊ï◊ù◊¢◊°◊ß◊î') || (x.includes('◊¢◊°◊ß◊î') && x.includes('◊°◊õ◊ï◊ù')) || x.includes('amount'));
    const hasDeb  = n.some(x => x.includes('◊°◊õ◊ï◊ù◊ó◊ô◊ï◊ë') || x.includes('◊ú◊™◊©◊ú◊ï◊ù') || x.includes('◊ú◊ó◊ô◊ï◊ë') || x.includes('◊ë◊©◊ó'));
    return hasDate && (hasName || hasTxn || hasDeb);
  }

  // A very permissive detector for a data row (date + name + any number) used for header-less tables
  function looksLikeTxnRow(row){
    if (!row || !row.length) return false;
    // date: any cell that can parse as date OR a previous carried date exists
    const hasDateAny = row.some(v=>!!parseDateFlex_v6(v));
    // name-like: any text cell with Hebrew/Latin letters that isn't a number
    const hasNameAny = row.some(v=>{
      const s=String(v==null?'':v).trim();
      return /[A-Za-z\u0590-\u05FF]/.test(s) && isNaN(Number(s.replace(/[\s,‚Ç™$‚Ç¨¬£]/g,'')));
    });
    // amount: any numeric-ish cell
    const hasAmtAny = row.some(v=>{ const n=numify_v6(v); return n!=null && Math.abs(n)>0; });
    return (hasNameAny && hasAmtAny && (hasDateAny));
  }

  let map = null; // {dateCol, nameCol, transCol, debitCol, hCol, zCol}
  let lastGoodDate = null;
  // Pre-compute a sheet-level heuristic mapping in case we never see a header
  const heur = detectHeuristic_v6(mat) || {};

  function rowHasAnyAmount(row){
    const probes = [map && map.hCol, map && map.zCol, map && map.debitCol, map && map.transCol].filter(i=>i!=null);
    for (const c of probes){ const n = numify_v6(row[c]); if (n!=null && Math.abs(n)>0) return true; }
    for (let c=0;c<row.length;c++){
      if (probes.includes(c)) continue;
      const n = numify_v6(row[c]); if (n!=null && Math.abs(n)>0) return true;
    }
    return false;
  }
  function rowBestName(row){
    let name = (map && map.nameCol!=null) ? row[map.nameCol] : null;
    if (name==null || String(name).trim()===''){
      name = bestNameFromRow_v6(row, [map && map.dateCol, map && map.hCol, map && map.zCol, map && map.debitCol, map && map.transCol]);
    }
    const s = String(name||'').trim();
    return s || '';
  }

  for (let r=0; r<mat.length; r++){
    const row = mat[r] || [];
    if (!row.length) continue;

    // (1) re-map when a new header row appears
    if (isHeaderRow(row)){
      const m = mapFromHeaderRow_v6(mat, r);
      map = {
        dateCol : m.dateCol,
        nameCol : m.nameCol,
        transCol: (m.transCol!=null ? m.transCol : null),
        debitCol: (m.debitCol!=null ? m.debitCol : null),
        hCol    : (m.hCol!=null ? m.hCol : null),
        zCol    : (m.zCol!=null ? m.zCol : null)
      };
      lastGoodDate = null;
      continue;
    }

    // Skip any accidental header-looking row mapped as data (Hebrew/Latin text in key columns)
    if (map && row && (
    (map.dateCol!=null && /[A-Za-z\u0590-\u05FF]/.test(String(row[map.dateCol]||''))) &&
    (map.nameCol!=null && /[A-Za-z\u0590-\u05FF]/.test(String(row[map.nameCol]||''))) &&
    (map.debitCol!=null && /[A-Za-z\u0590-\u05FF]/.test(String(row[map.debitCol]||'')))
    )) {
    continue;
    }

    // (2) If we still have no map but the row looks like data ‚Üí use heuristic mapping for the whole sheet
    if (!map && looksLikeTxnRow(row) && heur && (heur.dateCol!=null || heur.nameCol!=null)){
      map = {
        dateCol : heur.dateCol!=null?heur.dateCol:null,
        nameCol : heur.nameCol!=null?heur.nameCol:null,
        transCol: heur.transCol!=null?heur.transCol:null,
        debitCol: heur.debitCol!=null?heur.debitCol:null,
        hCol    : null,
        zCol    : null
      };
      // set lastGoodDate if this very row has a date
      const dTry = map.dateCol!=null ? row[map.dateCol] : null;
      const d0 = parseDateFlex_v6(dTry);
      if (d0) lastGoodDate = d0;
      // fall through to parse this row with the heuristic map
    }

    if (!map) continue; // haven‚Äôt seen a header or data yet

    const joined = String(row.map(x=>String(x||'')).join(' '));
    if (/(◊°◊î"?◊õ|◊°◊î◊õ|◊°◊ô◊õ◊ï◊ù|◊û◊ê◊ñ◊ü|◊ô◊™◊®◊î\s*(◊§◊™◊ô◊ó◊î|◊°◊ï◊§◊ô◊™)?)/.test(joined)) continue; // skip totals/balances

    // 1) date from mapped column (may be empty)
    const dRaw = map.dateCol!=null ? row[map.dateCol] : null;
    let d = parseDateFlex_v6(dRaw);
    if (!d && typeof dRaw === 'string') {
      const cleaned = dRaw.replace(/[\u200f\u200e\u202a\u202b\u202c\u2066\u2067\u2068\u2069\u00a0]/g,'').trim();
      if (cleaned === '' || cleaned === '-' || cleaned === '‚Äî') {
        // leave d as null so carry-forward can apply
      }
    }
    // 2) compute amounts/name first (we'll decide which date to use after)
    let creditFlag = null, t=null, db=null;

    if (map.hCol!=null || map.zCol!=null){
      const h = map.hCol!=null ? numify_v6(row[map.hCol]) : null;
      const z = map.zCol!=null ? numify_v6(row[map.zCol]) : null;
      if (h!=null && Math.abs(h)>0){ t=h; db=h; creditFlag=false; }
      else if (z!=null && Math.abs(z)>0){ t=z; db=z; creditFlag=true; }
    }
    if ((t==null || db==null) && map.debitCol!=null){
      const dval = numify_v6(row[map.debitCol]);
      if (dval!=null && Math.abs(dval)>0){ db=dval; if (t==null) t=dval; }
    }
    if ((t==null || db==null) && map.transCol!=null){
      const tval = numify_v6(row[map.transCol]);
      if (tval!=null && Math.abs(tval)>0){ t=tval; if (db==null) db=tval; }
    }
    if (t==null && db==null){
      let best = {n:null,abs:0};
      for (let c=0;c<row.length;c++){
        if ([map.hCol,map.zCol,map.debitCol,map.transCol].includes(c)) continue;
        const n = numify_v6(row[c]);
        if (n!=null && Math.abs(n)>best.abs){ best={n,abs:Math.abs(n)}; }
      }
      if (best.n!=null){ t=best.n; db=best.n; }
    }

    const name = rowBestName(row);

    // 3) carry-forward date logic for merged-date rows
    if (!d && name && (t!=null || db!=null) && rowHasAnyAmount(row) && lastGoodDate){
      d = lastGoodDate;
    }
    if (d) lastGoodDate = d; // remember good date for following merged rows

    if (!d || !name) continue;

    pushRow(d, name, t, db, creditFlag);
  }

  return rows;
}

function extractFromWorkbook_v6(file){
  return new Promise(function(res, rej){
    const reader = new FileReader();
    const isCSV = /\.csv$/i.test(file.name);
    reader.onload = function(e){
      try{
        let all = [];
        const data = isCSV ? e.target.result : new Uint8Array(e.target.result);
        const wb = isCSV ? XLSX.read(data, { type:'string', cellDates:true })
                         : XLSX.read(data, { type:'array',  cellDates:true });
        wb.SheetNames.forEach(sn=>{
          const ws = wb.Sheets[sn]; if (!ws) return;
          all = all.concat(extractFromSheet_v6(ws, sn));
        });
        if (MT_DEBUG){ console.log('[MoneyTron][parsed]',{file:file.name,rowsAll:all.length,sample:all.slice(0,12)}); alert('Parsed '+all.length+' rows from '+file.name); }
        res(all);
      }catch(err){ rej(err); }
    };
    reader.onerror = rej;
    if (isCSV) reader.readAsText(file,'utf-8'); else reader.readAsArrayBuffer(file);
  });
}
/* ================== END file parsing ================== */

/* ================== Auto-category helpers ================== */

function normHebEnVendor(s){
  if (!s) return '';
  // strip RTL/LRM etc
  s = String(s).replace(/[\u200f\u200e\u202a\u202b\u202c\u2066\u2067\u2068\u2069\u00a0]/g,'');
  // remove quotes, punctuation except &/+
  s = s.replace(/[\"'`~!@#%^*()_=\$begin:math:display$$end:math:display${}|;:<>?,.]/g,' ');
  // common Hebrew company suffixes / noise
  s = s.replace(/\b◊ë◊¢[\"◊¥']?◊û\b/g,'');  // ◊ë◊¢"◊û variants
  s = s.replace(/\b◊ó\.?◊§\.?\b/g,'');   // ◊ó"◊§
  // latin company suffixes
  s = s.replace(/\b(ltd|inc|llc)\b/gi,'');
  // collapse spaces, trim, lowercase
  s = s.replace(/\s+/g,' ').trim().toLowerCase();
  return s;
}

// Token-based similarity (Jaccard-like)
function tokenSim(a,b){
  const A = new Set(a.split(' ').filter(Boolean));
  const B = new Set(b.split(' ').filter(Boolean));
  if (!A.size || !B.size) return 0;
  let inter=0;
  for (const t of A) if (B.has(t)) inter++;
  const uni = A.size + B.size - inter;
  return inter/uni;
}

function amountClose(a,b){
  const A = Number(a||0), B = Number(b||0);
  if (!isFinite(A) || !isFinite(B)) return false;
  const tol = Math.max(1, 0.02 * Math.max(Math.abs(A), Math.abs(B))); // ¬±1‚Ç™ or 2%
  return Math.abs(A-B) <= tol;
}

// Build in-memory index from past_data
function buildPastIndex(past){
  const arr = Array.isArray(past) ? past
            : (past && Array.isArray(past.past_data)) ? past.past_data
            : [];
  const byVendor = new Map();
  for (const r of arr){
    const key = normHebEnVendor(r.name);
    if (!key) continue;
    let obj = byVendor.get(key);
    if (!obj){
      obj = { rawNames:new Set(), samples:[], catCount:new Map(), subCount:new Map(), typeCount:new Map(), amountList:[] };
      byVendor.set(key, obj);
    }
    obj.rawNames.add(r.name||'');
    obj.samples.push(r);
    // frequency tallies
    if (r.category) obj.catCount.set(r.category, (obj.catCount.get(r.category)||0)+1);
    if (r.subcategory) obj.subCount.set(r.subcategory, (obj.subCount.get(r.subcategory)||0)+1);
    if (r.type) obj.typeCount.set(r.type, (obj.typeCount.get(r.type)||0)+1);
    if (Number.isFinite(Number(r.debit))) obj.amountList.push(Number(r.debit));
  }
  return byVendor;
}

function majority(map){
  let best = null, max = -1;
  for (const [k,v] of map.entries()){
    if (v>max){ max=v; best=k; }
  }
  return best;
}

function bestType(obj){ return majority(obj.typeCount) || 'Expense'; }
function bestCategory(obj){ return majority(obj.catCount) || ''; }
function bestSubcategory(obj){ return majority(obj.subCount) || ''; }

function validateCatSub(chosenCat, chosenSub, categories){
  if (!chosenCat) return {category:'', subcategory:''};
  const subs = (categories && categories[chosenCat]) || [];
  if (!chosenSub || subs.indexOf(chosenSub) === -1){
    // keep category, drop sub if it doesn't exist in categories.json
    return {category: chosenCat, subcategory: ''};
  }
  return {category: chosenCat, subcategory: chosenSub};
}

// Try to pick cat/sub/type for a single row
function matchOne(row, byVendor, categories){
  const nameKey = normHebEnVendor(row.name);
  const debit = Number(row.debit||row.amount||0);

  // A) Exact name bucket
  const exact = byVendor.get(nameKey);
  if (exact){
    // A1) Name + amount within tolerance
    const close = exact.samples.filter(s => amountClose(Number(s.debit||s.amount||0), debit));
    if (close.length){
      // majority within close matches
      const catCount = new Map(), subCount = new Map(), typeCount = new Map();
      for (const s of close){
        if (s.category) catCount.set(s.category, (catCount.get(s.category)||0)+1);
        if (s.subcategory) subCount.set(s.subcategory, (subCount.get(s.subcategory)||0)+1);
        if (s.type) typeCount.set(s.type, (typeCount.get(s.type)||0)+1);
      }
      const pickedType = majority(typeCount) || bestType(exact);
      const pickedCat  = majority(catCount) || bestCategory(exact);
      const pickedSub  = majority(subCount) || bestSubcategory(exact);
      const v = validateCatSub(pickedCat, pickedSub, categories);
      return { ...v, type: pickedType, confidence: 0.98, reason: 'name+amount' };
    }
    // A2) Name-only majority
    const v = validateCatSub(bestCategory(exact), bestSubcategory(exact), categories);
    return { ...v, type: bestType(exact), confidence: 0.9, reason: 'name-only' };
  }

  // B) Fuzzy: look across all vendors for near names
  let best = {score:0, obj:null, key:null};
  for (const [k,obj] of byVendor.entries()){
    // quick contains or token Jaccard
    const s1 = nameKey, s2 = k;
    const cont = (s1 && s2) && (s1.includes(s2) || s2.includes(s1)) ? 1 : 0;
    const js  = tokenSim(s1,s2);
    const score = Math.max(js, cont ? 0.86 : 0);
    if (score > best.score) best = {score, obj, key:k};
  }
  if (best.obj && best.score >= 0.85){
    // Also see if amount aligns with any of the vendor's amounts
    const anyClose = best.obj.samples.some(s => amountClose(Number(s.debit||s.amount||0), debit));
    const pickedType = bestType(best.obj);
    const pickedCat  = bestCategory(best.obj);
    const pickedSub  = bestSubcategory(best.obj);
    const v = validateCatSub(pickedCat, pickedSub, categories);
    return { ...v, type: pickedType, confidence: anyClose?0.88:0.82, reason: anyClose?'fuzzy+amount':'fuzzy' };
  }

  // No confident guess
  return { category:'', subcategory:'', type:(row.type||'Expense'), confidence:0.0, reason:'none' };
}

async function autoCategorizeRows(builtRows){
  // load personal data & categories
  const [pastResp, cats] = await Promise.all([
  API.getPast().catch(()=>({past_data:[]})),
  API.getCategories().catch(()=>({}))
  ]);
  // pastResp is { past_data: [...] } (server shape) or an array (fallbacks/tests)
  const pastArr = Array.isArray(pastResp) ? pastResp
                : (pastResp && Array.isArray(pastResp.past_data)) ? pastResp.past_data
                : [];
  const byVendor = buildPastIndex(pastArr);
  const out = builtRows.map(r=>{
    const guess = matchOne(r, byVendor, cats);
    const next = Object.assign({}, r);
    // Only set fields when confident enough. Subcategory must be present for "Categorized".
    if (guess.confidence >= 0.85){
      next.type = guess.type || next.type;
      next.category = guess.category || '';
      next.subcategory = guess.subcategory || '';
      if (next.category || next.subcategory){
        next.__auto = {confidence: guess.confidence, reason: guess.reason};
      }
    }
    return next;
  });
  return out;
}

/* ================= Components (unchanged UI) ================= */
function TitleBar({user,onSwitch}){ return (
  <div className="topbar">
    <div className="pill welcome">Welcome, {user}!</div>
    <button className="ghost btn" onClick={onSwitch}>Switch User</button>
  </div>
);}

function LoginView({onLogin}){
  const ref=React.useRef(null);
  function doLogin(){ var n=(ref.current&&ref.current.value||'').trim(); if(!n) return; onLogin(n); }
  return (
    <div className="wrap">
      <h1 className="title">MoneyTron ‚Äî Multi-User Money Tracker</h1>
      <div className="panel frame" style={{maxWidth:900, margin:'0 auto'}}>
        <div className="topbar" style={{marginBottom:16}}>
          <input ref={ref} type="text" placeholder="Enter your name (e.g., Roy)" style={{width:300}} onKeyDown={(e)=>{if(e.key==='Enter') doLogin();}}/>
          <button className="pill" onClick={doLogin}>Login</button>
        </div>
      </div>
    </div>
  );
}

/* ---------- Categories ---------- */
function CategoryCard({cat, subs, onDeleteCat, onAddSub, onDeleteSub}){
  const [subInput,setSubInput]=React.useState('');
  function add(){ if(subInput.trim()){ onAddSub(cat, subInput.trim()); setSubInput(''); } }
  return (
    <div className="cat-card" dir="auto">
      <div className="cat-head">
        <div className="cat-name" dir="auto">{cat}</div>
        <span className="badge">{(subs||[]).length} subcategories</span>
        <div style={{flex:1}}></div>
        <button className="btn btn-xs danger" onClick={()=>onDeleteCat(cat)}>Delete</button>
      </div>
      <div>
        <div>{(!subs || subs.length===0) && <div className="muted">No subcategories yet.</div>}
          {(subs||[]).map(s=>(
            <span className="chip" key={s} dir="auto">{s}
              <a href="#" onClick={(e)=>{e.preventDefault(); onDeleteSub(cat,s);}} title="Remove">√ó</a>
            </span>
          ))}
        </div>
        <div className="controls" style={{marginTop:8}}>
          <input className="input-xs" type="text" placeholder={'Add subcategory to '+cat} value={subInput} onChange={(e)=>setSubInput(e.target.value)} onKeyDown={(e)=>{if(e.key==='Enter') add();}}/>
          <button className="btn btn-xs" onClick={add}>+ Add</button>
        </div>
      </div>
    </div>
  );
}
function CategoriesTab({user, categories, onSaved}){
  const [cats,setCats]=React.useState(categories||{});
  const [q,setQ]=React.useState(''); const [newCat,setNewCat]=React.useState('');
  React.useEffect(()=>setCats(categories||{}),[categories]);
  const names=React.useMemo(()=>Object.keys(cats).sort((a,b)=>a.localeCompare(b)),[cats]);
  const totalCats=names.length, totalSubs=names.reduce((a,c)=>a+(cats[c]?cats[c].length:0),0), avgPer=totalCats?totalSubs/totalCats:0;
  function persist(next){ setCats(next); API.saveCategories(next).catch(()=>{}); onSaved && onSaved(next); }
  function refresh(){ API.getCategories().then(s=>{ setCats(s||{}); onSaved && onSaved(s||{}); }); }
  function addCategory(){ const name=newCat.trim(); if(!name) return; if(cats[name]){alert('Category exists'); return;} persist(Object.assign({},cats,{[name]:[]})); setNewCat(''); }
  function deleteCategory(c){ if(!confirm('Delete category "'+c+'"?')) return; const n=Object.assign({},cats); delete n[c]; persist(n); }
  function addSub(c,s){ if(!s.trim()) return; const arr=(cats[c]||[]).slice(); if(arr.indexOf(s)!==-1){alert('Sub exists'); return;} arr.push(s); persist(Object.assign({},cats,{[c]:arr})); }
  function delSub(c,s){ persist(Object.assign({},cats,{[c]:(cats[c]||[]).filter(x=>x!==s)})); }
  const filtered=React.useMemo(()=>{ const x=q.trim().toLowerCase(); if(!x) return names; return names.filter(c=>c.toLowerCase().includes(x) || (cats[c]||[]).some(s=>String(s).toLowerCase().includes(x))); },[q,names,cats]);
  return (
    <React.Fragment>
      <div className="section-title">üè∑Ô∏è Category Management for {user}</div>
      <div className="kpis">
        <div className="kpi k1">Categories<span className="n">{(totalCats)}</span></div>
        <div className="kpi k2">Subcategories<span className="n">{(totalSubs)}</span></div>
        <div className="kpi k3">Avg per Category<span className="n">{(avgPer.toFixed(1))}</span></div>
      </div>
      <div className="panel" style={{marginBottom:12}}>
        <div className="toolbar">
          <div className="left"><input className="input-xs" type="text" placeholder="Search Categories & Subcategories" value={q} onChange={(e)=>setQ(e.target.value)}/></div>
          <div className="middle"><button className="btn btn-xs" onClick={refresh}>‚Üª Refresh Categories</button><div className="muted">Update from server</div></div>
          <div className="right"><input className="input-xs" type="text" placeholder="Category name (e.g., Food, Transport)" value={newCat} onChange={(e)=>setNewCat(e.target.value)} onKeyDown={(e)=>{if(e.key==='Enter') addCategory();}}/><button className="btn btn-xs primary" onClick={addCategory}>Add</button></div>
        </div>
      </div>
      <div className="cat-grid">
        {filtered.length===0 && <div className="panel" style={{gridColumn:'1 / -1'}}>No categories match your search.</div>}
        {filtered.map(c=><CategoryCard key={c} cat={c} subs={cats[c]||[]} onDeleteCat={deleteCategory} onAddSub={addSub} onDeleteSub={delSub}/>)}
      </div>
    </React.Fragment>
  );
}

/* ---------- Transactions ---------- */
function TransactionsTab({rows,setRows,categories,onSaved}){
  const [msg,setMsg]=React.useState(''); const [sortKey,setSortKey]=React.useState('date'); const [sortDir,setSortDir]=React.useState('asc');
  const [q,setQ]=React.useState('');
  function addManual(){
    const now = dayjs();
    const date_iso = now.format('YYYY-MM-DD');
    const r={ 
      id:'m_'+Date.now(), 
      tag:now.month() + 1, 
      date: date_iso,
      date_iso: date_iso,
      date_str: formatDMY(date_iso),
      year: now.year(),
      month_tag: now.month() + 1,
      name:'', amount:0, debit:0, currency:'ILS', type:'Expense', category:'', subcategory:'', notes:'', vi:false, manual:true 
    };
    const next=[r].concat(rows); setRows(next); API.saveStage(next).catch(()=>{});
  }
  async function onUpload(e){
    const f=e.target.files && e.target.files[0]; if(!f) return;
    try{
      // Ask user for tag and year
      var suggested=Number(dayjs().format('M'));
      var tgStr=window.prompt('Enter month tag (1‚Äì12) for this upload:', String(suggested));
      if (!tgStr) { e.target.value=''; return; } // User cancelled
      var tag=Number(tgStr); 
      if(!isFinite(tag)||tag<1||tag>12) {
        alert('Invalid tag. Must be 1-12.');
        e.target.value='';
        return;
      }
      
      // Store tag globally so pushRow can validate dates against it
      window.__currentUploadTag = tag;
      
      var suggestedYear=dayjs().year();
      var yearStr=window.prompt('Enter year for this upload:', String(suggestedYear));
      if (!yearStr) { e.target.value=''; return; } // User cancelled
      var year=Number(yearStr);
      if(!isFinite(year)||year<2000||year>2100) {
        alert('Invalid year. Must be 2000-2100.');
        e.target.value='';
        return;
      }
      
      const extracted=await extractFromWorkbook_v6(f);
      
      // Build transactions with user-provided tag and year
      const built=extracted.map((x,i)=>{
        const date_iso = x.date_iso || x.date;
        const date_str = x.date_str || formatDMY(date_iso);
        
        return {
          id:'u_'+i+'_'+Date.now(), 
          tag: tag,
          date: date_iso,
          date_iso: date_iso,
          date_str: date_str,
          year: year,
          month_tag: tag,
          name: x.name,
          amount:Math.abs(Number(x.amount||0)), 
          debit:Number(Math.abs(x.debit||0)),
          currency:'ILS',
          type: x.__credit ? 'Income' : 'Expense',
          category:'', subcategory:'', notes:'', vi:false, manual:false
        };
      });

      // Auto-categorize using past_data + categories
      const autoed = await autoCategorizeRows(built);
      
      const invalidCount = extracted.length - autoed.length;
      setRows(autoed);
      setMsg(`‚úÖ Imported: ${autoed.length} rows${invalidCount > 0 ? ` | Skipped: ${invalidCount} invalid` : ''} | Tag: ${tag}, Year: ${year}`);
      await API.saveStage(autoed);
    }catch(err){ alert('Parse failed: '+err.message); }
    e.target.value='';
  }
  function saveAll(){
    if(!rows.length){ alert('No transactions to save'); return; }
    const need = rows.some(r=>!r.subcategory); if(need){ alert('Please set Sub-category for all rows'); return; }
    API.saveTransactions(rows).then(()=>{ setRows([]); setMsg(''); onSaved(); }).catch(err=>alert('Save failed: '+err.message));
  }
  function patch(id,patch){ const i=rows.findIndex(r=>r.id===id); if(i<0) return; const next=rows.slice(); next[i]=Object.assign({},next[i],patch); setRows(next); API.saveStage(next).catch(()=>{}); }
  function delRow(id){ const next=rows.filter(r=>r.id!==id); setRows(next); API.saveStage(next).catch(()=>{}); }
  function toggleType(id){ const r=rows.find(x=>x.id===id); if(!r) return; patch(id,{type:r.type==='Expense'?'Income':'Expense'}); }
  // Get allowed currencies from window.settings if available, else default
  const allowedCurrencies = (window.settings && window.settings.allowedCurrencies) || (typeof settings !== 'undefined' && settings.allowedCurrencies) || ["ILS","USD"];
  function toggleCurrency(id){
    const r=rows.find(x=>x.id===id); if(!r) return;
    const allowed = allowedCurrencies.length ? allowedCurrencies : ["ILS","USD"];
    const cur = r.currency || allowed[0];
    const idx = allowed.indexOf(cur);
    const next = allowed[(idx+1)%allowed.length];
    patch(id,{currency:next});
  }
  function onAmount(id,val){ const r=rows.find(x=>x.id===id); if(!r) return; const amt=parseAmount(val); patch(id,{amount:Math.abs(amt)}); }
  function onDebit(id,val){ const r=rows.find(x=>x.id===id); if(!r) return; const amt=parseAmount(val); patch(id,{debit:Math.abs(amt)}); }
  // inline edit buffers for Debit (so we don't auto-format while typing)
  function onDebitEditChange(id, val){
    patch(id, { debit_edit: val });
  }
  function onDebitEditBlur(id){
    const r = rows.find(x => x.id === id); if (!r) return;
    const raw = (r.debit_edit != null ? r.debit_edit : r.debit);
    const n = parseAmount(raw);
    patch(id, { debit: Math.abs(n||0), debit_edit: undefined });
  }

  const needCat = rows.filter(r=>!r.subcategory).length; const categorized=rows.length-needCat;
  const totalSigned=rows.reduce((a,r)=>a+(r.type==='Income'?-Number(r.debit||0):Number(r.debit||0)),0);
  function setSort(k){ if(sortKey===k) setSortDir(sortDir==='asc'?'desc':'asc'); else { setSortKey(k); setSortDir('asc'); } }
  function v(r,k){ 
    switch(k){ 
      case 'tag':return Number(r.tag||0); 
      case 'date':return new Date(String(r.date||'1900-01-01')); // Return Date object for proper sorting
      case 'name':return String(r.name||'').toLowerCase(); 
      case 'amount':return Number(r.amount||0); 
      case 'debit':return Number(r.debit||0); 
      case 'type':return String(r.type||''); 
      case 'category':return String(r.category||'').toLowerCase(); 
      case 'subcategory':return String(r.subcategory||'').toLowerCase(); 
      case 'notes':return String(r.notes||'').toLowerCase(); 
      case 'vi':return r.vi?1:0; 
      default:return ''; 
    } 
  }
  
  // Enhanced search that includes numbers
  const filtered = React.useMemo(() => {
    const x = (q || '').trim().toLowerCase();
    if (!x) return rows;
    return (rows || []).filter(r => {
      return [
        r.date, r.name, r.notes, r.category, r.subcategory, r.tag,
        String(r.amount||0), String(r.debit||0)
      ].some(v => String(v == null ? '' : v).toLowerCase().includes(x));
    });
  }, [rows, q]);
  
  const view=React.useMemo(()=>{ 
    const a=filtered.slice(); 
    a.sort((x,y)=>{ 
      const vx=v(x,sortKey), vy=v(y,sortKey); 
      let c;
      if (sortKey === 'date') {
        // Special handling for date comparison
        c = vx.getTime() - vy.getTime();
      } else if (typeof vx==='number'&&typeof vy==='number') {
        c = vx - vy;
      } else {
        c = vx < vy ? -1 : vx > vy ? 1 : 0;
      }
      return sortDir==='asc'?c:-c; 
    }); 
    return a; 
  },[filtered,sortKey,sortDir]);
  function hdr(lbl,key,cls){ const ar=sortKey===key?(sortDir==='asc'?' ‚Üë':' ‚Üì'):' ‚Üë‚Üì'; return <th className={cls||''} onClick={()=>setSort(key)}>{lbl}{ar}</th>; }

  async function deleteAllTransactions() {
    if (!rows.length) { alert('No transactions to delete'); return; }
    if (!window.confirm('Are you sure you want to delete all current (last upload) transactions?')) return;
    try {
      await fetch('/api/current-month/reset', { method: 'POST', headers: { 'Content-Type': 'application/json', 'X-User': localStorage.getItem('user') } });
      setRows([]);
      setMsg('All current month transactions deleted.');
    } catch (err) {
      alert('Failed to delete: ' + (err.message || err));
    }
  }
  return (
    <React.Fragment>
      {msg && <div className="panel" style={{marginBottom:12}}>{msg}</div>}
      <div className="kpis">
        <div className="kpi k1">Total Transactions<span className="n">{(rows.length)}</span></div>
        <div className="kpi k2">Total Amount<span className="n">‚Ç™{fmt2(totalSigned)}</span></div>
        <div className="kpi k3">Categorized<span className="n">{(categorized)}</span></div>
        <div className="kpi k4">Need Categories<span className="n">{(needCat)}</span></div>
      </div>

      <div className="controls" style={{marginBottom:10}}>
        <div className="left" style={{display:'flex',alignItems:'center',gap:8}}>
          <input className="input-xs" type="text" placeholder="Search by name, amount, notes‚Ä¶" value={q} onChange={(e)=>setQ(e.target.value)}/>
          <button className="btn btn-xs" onClick={()=>setQ('')}>Clear</button>
        </div>
        <div className="right" style={{display:'flex',alignItems:'center',gap:8}}>
          <label className="btn">üìÅ Upload
            <input type="file" accept=".xlsx,.xls,.csv" style={{display:'none'}} onChange={onUpload}/>
          </label>
          <button className="btn" onClick={addManual}>+ Add Manual Row</button>
          <button className="btn danger" style={{marginLeft:10}} onClick={deleteAllTransactions}>üóëÔ∏è Delete All</button>
          <button className="btn primary" onClick={saveAll}>üíæ Save All</button>
        </div>
      </div>

      <div className="panel">
        <table>
          <thead><tr>
            <th className="nosort">‚úñ</th>
            {hdr('Tag','tag','w-tag')}
            {hdr('Date','date','w-date')}
            {hdr('Name','name','w-name')}
            {hdr('Transaction Amount','amount','w-amt')}
            {hdr('Debit Amount (ILS)','debit','w-debit')}
            {hdr('Type','type')}
            {hdr('Category','category','w-cat')}
            {hdr('Sub-category','subcategory','w-sub')}
            {hdr('Notes','notes','w-notes')}
            {hdr('Vi','vi')}
          </tr></thead>
          <tbody>
            {view.length? view.map(r=>{
              const id=r.id || (r.tag+'_'+r.date+'_'+r.name);
              const manual=!!r.manual; const currency=r.currency||'ILS';
              // Map currency code to symbol
              const currencySymbols = { ILS: '‚Ç™', USD: '$', EUR: '‚Ç¨', GBP: '¬£' };
              return (
                <tr key={id} className={r.vi?'row-vi':''}>
                  <td style={{width:48}}><button className="btn danger" onClick={()=>delRow(id)}>‚úñ</button></td>

                  <td className="w-tag">
                    {manual
                      ? <input 
                          type="number" 
                          value={(r.month_tag || r.tag)==null?'':(r.month_tag || r.tag)} 
                          onChange={(e)=>patch(id,{tag:Number(e.target.value||0), month_tag:Number(e.target.value||0)})}
                          title="Month (1-12)"
                        />
                      : <span className="ro-tag" title="Month tag">{(r.month_tag!=null ? r.month_tag : (r.tag!=null ? r.tag : '‚Äî'))}</span>}
                  </td>

                  <td className="w-date">
                    {manual ? (
                      <input 
                        type="text" 
                        placeholder="DD-MM-YYYY"
                        value={r.date_str || formatDMY(r.date_iso || r.date)} 
                        onChange={(e)=>{
                          const dmyValue = e.target.value;
                          const isoValue = parseDMYtoISO(dmyValue);
                          const d = dayjs(isoValue);
                          patch(id, {
                            date: isoValue,
                            date_iso: isoValue,
                            date_str: dmyValue,
                            year: d.isValid() ? d.year() : r.year,
                            month_tag: d.isValid() ? d.month() + 1 : r.month_tag,
                            tag: d.isValid() ? d.month() + 1 : r.tag
                          });
                        }}
                      />
                    ) : (
                      <input 
                        className="locked" 
                        readOnly={true} 
                        type="text" 
                        value={r.date_str || formatDMY(r.date_iso || r.date)}
                      />
                    )}
                  </td>

                  <td className="w-name" style={{textAlign:'center'}}>
                    {manual
                      ? <div className="cell-hscroll"><input className="fit" type="text" value={r.name||''} title={r.name||''} onChange={(e)=>patch(id,{name:e.target.value})}/></div>
                      : <div className="cell-hscroll ro-name" title={r.name||''}>{r.name||''}</div>}
                  </td>

                  <td className="w-amt">
                    <div style={{display:'flex',alignItems:'center',justifyContent:'center',gap:6}}>
                      <button className="currency-toggle" onClick={()=>toggleCurrency(id)}>{currencySymbols[currency] || currency}</button>
                      {manual
                        ? <input className="num-input" type="text" value={r.amount_edit != null ? r.amount_edit : String(fmt2(r.amount))} onChange={e=>patch(id,{amount_edit:e.target.value})} onBlur={()=>{const amt=parseAmount(r.amount_edit!=null?r.amount_edit:r.amount);patch(id,{amount:Math.abs(amt)||0,amount_edit:undefined});}}/>
                        : <input className={'locked num-input'} readOnly={true} type="text" value={fmt2(r.amount)}/>
                      }
                    </div>
                  </td>

                  <td className="w-debit">
                    <input
                      className="num-input"
                      type="text"
                      value={(r.debit_edit != null ? r.debit_edit : String(fmt2(r.debit)))}
                      onChange={(e)=>onDebitEditChange(id, e.target.value)}
                      onBlur={()=>onDebitEditBlur(id)}
                    />
                  </td>

                  <td><button className={'type-pill '+(r.type==='Expense'?'type-exp':'type-inc')} onClick={()=>toggleType(id)}>{r.type}</button></td>
                  <td className="w-cat"><select value={r.category||''} onChange={(e)=>patch(id,{category:e.target.value, subcategory:''})}><option value="">‚Äî Select ‚Äî</option>{Object.keys(categories).map(c=><option key={c} value={c}>{c}</option>)}</select></td>
                  <td className="w-sub"><select value={r.subcategory||''} onChange={(e)=>patch(id,{subcategory:e.target.value})}><option value="">‚Äî</option>{((categories[r.category])||[]).map(s=><option key={s} value={s}>{s}</option>)}</select></td>
                  <td className="w-notes" style={{textAlign:'left'}}><input type="text" value={r.notes||''} onChange={(e)=>patch(id,{notes:e.target.value})}/></td>
                  <td><input type="checkbox" checked={!!r.vi} onChange={(e)=>patch(id,{vi:e.target.checked})}/></td>
                </tr>
              );
            }) : <tr><td colSpan="11" style={{textAlign:'center',color:'#6b7280'}}>No Transactions Yet</td></tr>}
          </tbody>
        </table>
      </div>
    </React.Fragment>
  );
}

/* ---------- Data (PAST), Summary, Settings ‚Äî unchanged from your last file ---------- */
/* (Keeping as-is for brevity) */

/* ---------- Data (PAST) ‚Äî with filters for Tag, Category, Sub-category, Name ---------- */
function DataTab({past,categories,onSaved}){
  const [rows,setRows]=React.useState(Array.isArray(past)?past.slice():[]);
  const [q,setQ]=React.useState(''); const [sortKey,setSortKey]=React.useState('date'); const [sortDir,setSortDir]=React.useState('asc'); const [saving,setSaving]=React.useState(false);
  React.useEffect(()=>setRows(Array.isArray(past)?past.slice():[]),[JSON.stringify(past||[])]);
  const totalTx=rows.length; const catCount=Object.keys(categories||{}).length; 
  const activeMonths=(function(list){var s={}; list.forEach(r=>{var t=String(r.tag||r.month_tag||''); if(t&&t!=='0') s[t]=1;}); return Object.keys(s).length;})(rows);
  // Single filter: select column and enter value
  // Default: if there are tags, set filterCol to 'tag' and filterVal to max tag
  const tags = React.useMemo(() => rows.map(r => Number(r.tag)).filter(n => !isNaN(n)), [rows]);
  const maxTag = tags.length ? Math.max(...tags) : '';
  const [filterCol, setFilterCol] = React.useState(tags.length ? 'tag' : '');
  const [filterVal, setFilterVal] = React.useState(tags.length ? String(maxTag) : '');
  // Optional second filter (applies after the first)
  const [filter2Col, setFilter2Col] = React.useState('');
  const [filter2Val, setFilter2Val] = React.useState('');
  // If rows change and maxTag changes, update filterCol/Val if filterCol is empty or tag
  React.useEffect(() => {
    if (tags.length && (!filterCol || filterCol === 'tag') && (!filterVal || filterVal !== String(maxTag))) {
      setFilterCol('tag');
      setFilterVal(String(maxTag));
    }
  }, [tags.length, maxTag]);
  function patch(id,p){ const i=rows.findIndex(r=>r.id===id); if(i<0) return; const n=rows.slice(); n[i]=Object.assign({},n[i],p); setRows(n); }
  function delRow(id){ setRows(rows.filter(r=>r.id!==id)); }
  function toggleType(id){ const r=rows.find(x=>x.id===id); if(!r) return; patch(id,{type:r.type==='Expense'?'Income':'Expense'}); }
  // Toggle currency cycles through allowed currencies from settings
  const allowedCurrencies = (window.settings && window.settings.allowedCurrencies) || (typeof settings !== 'undefined' && settings.allowedCurrencies) || ["ILS","USD"];
  function toggleCurrency(id) {
    const r = rows.find(x => x.id === id); if (!r) return;
    const allowed = allowedCurrencies.length ? allowedCurrencies : ["ILS","USD"];
    const cur = r.currency || allowed[0];
    const idx = allowed.indexOf(cur);
    const next = allowed[(idx+1)%allowed.length];
    patch(id, { currency: next });
  }
  // inline edit buffers for Amount and Debit so typing isn't auto-formatted
  function onAmountEditChange(id, val){
    patch(id, { amount_edit: val });
  }
  function onAmountEditBlur(id){
    const r = rows.find(x => x.id === id); if (!r) return;
    const raw = (r.amount_edit != null ? r.amount_edit : r.amount);
    const n = parseAmount(raw);
    patch(id, { amount: Math.abs(n||0), amount_edit: undefined });
  }
  function onDebitEditChange(id, val){
    patch(id, { debit_edit: val });
  }
  function onDebitEditBlur(id){
    const r = rows.find(x => x.id === id); if (!r) return;
    const raw = (r.debit_edit != null ? r.debit_edit : r.debit);
    const n = parseAmount(raw);
    patch(id, { debit: Math.abs(n||0), debit_edit: undefined });
  }
  // Get unique values for dropdowns
  const categoryOptions = React.useMemo(() => {
    const fromData = Array.from(new Set(rows.map(r => r.category).filter(Boolean))).sort();
    const fromCategories = Object.keys(categories || {}).sort();
    return Array.from(new Set([...fromData, ...fromCategories]));
  }, [rows, categories]);
  
  const subcategoryOptions = React.useMemo(() => {
    const fromData = Array.from(new Set(rows.map(r => r.subcategory).filter(Boolean))).sort();
    const fromCategories = Object.values(categories || {}).flat().filter(Boolean);
    return Array.from(new Set([...fromData, ...fromCategories]));
  }, [rows, categories]);

  function save(){ setSaving(true); API.savePast(rows).then(()=>{ setSaving(false); onSaved && onSaved(rows); alert('Past data updated.'); }).catch(e=>{ setSaving(false); alert('Save failed: '+e.message); }); }
  function setSort(k){ if(sortKey===k) setSortDir(sortDir==='asc'?'desc':'asc'); else { setSortKey(k); setSortDir('asc'); } }
  function v(r,k){ 
    switch(k){ 
      case 'tag':return Number(r.tag||0); 
      case 'date':return new Date(String(r.date||'1900-01-01')); // Return Date object for proper sorting
      case 'name':return String(r.name||'').toLowerCase(); 
      case 'amount':return Number(r.amount||0); 
      case 'debit':return Number(r.debit||0); 
      case 'type':return String(r.type||''); 
      case 'category':return String(r.category||'').toLowerCase(); 
      case 'subcategory':return String(r.subcategory||'').toLowerCase(); 
      case 'notes':return String(r.notes||'').toLowerCase(); 
      case 'vi':return r.vi?1:0; 
      default:return ''; 
    } 
  }
  const filtered = React.useMemo(() => {
    const x = (q || '').trim().toLowerCase();
    return (rows || []).filter(r => {
      // Enhanced text search (q) - includes numbers
      const matchText = !x || [
        r.date, r.name, r.notes, r.category, r.subcategory, r.tag,
        String(r.amount||0), String(r.debit||0)
      ].some(v => String(v == null ? '' : v).toLowerCase().includes(x));
      
      // Single column filter
      let matchCol = true;
      if (filterCol && filterVal.trim()) {
        const val = String(filterVal).toLowerCase();
        switch (filterCol) {
          case 'tag': matchCol = String(r.tag == null ? '' : r.tag).toLowerCase().includes(val); break;
          case 'name': matchCol = String(r.name == null ? '' : r.name).toLowerCase().includes(val); break;
          case 'category': matchCol = String(r.category == null ? '' : r.category).toLowerCase().includes(val); break;
          case 'subcategory': matchCol = String(r.subcategory == null ? '' : r.subcategory).toLowerCase().includes(val); break;
          default: matchCol = true;
        }
      }
      // Second column filter (applied on top of the first)
      let matchCol2 = true;
      if (filter2Col && filter2Val.trim()) {
        const val2 = String(filter2Val).toLowerCase();
        switch (filter2Col) {
          case 'tag':         matchCol2 = String(r.tag == null ? '' : r.tag).toLowerCase().includes(val2); break;
          case 'name':        matchCol2 = String(r.name == null ? '' : r.name).toLowerCase().includes(val2); break;
          case 'category':    matchCol2 = String(r.category == null ? '' : r.category).toLowerCase().includes(val2); break;
          case 'subcategory': matchCol2 = String(r.subcategory == null ? '' : r.subcategory).toLowerCase().includes(val2); break;
          default:            matchCol2 = true;
        }
      }
      return matchText && matchCol && matchCol2;
    });
  }, [rows, q, filterCol, filterVal, filter2Col, filter2Val]);
  // No longer need tagOptions, catOptions, subOptions, nameOptions
  const view=React.useMemo(()=>{ 
    const a=filtered.slice(); 
    a.sort((x,y)=>{ 
      const vx=v(x,sortKey), vy=v(y,sortKey); 
      let c;
      if (sortKey === 'date') {
        // Special handling for date comparison
        c = vx.getTime() - vy.getTime();
      } else if (typeof vx==='number'&&typeof vy==='number') {
        c = vx - vy;
      } else {
        c = vx < vy ? -1 : vx > vy ? 1 : 0;
      }
      return sortDir==='asc'?c:-c; 
    }); 
    return a; 
  },[filtered,sortKey,sortDir]);
  function hdr(lbl,key,cls){ const ar=sortKey===key?(sortDir==='asc'?' ‚Üë':' ‚Üì'):' ‚Üë‚Üì'; return <th className={cls||''} onClick={()=>setSort(key)}>{lbl}{ar}</th>; }
  return (
    <React.Fragment>
      <div className="section-title">üìä Transaction Data</div>
      <div className="kpis">
        <div className="kpi k1">Total Transactions<span className="n">{(totalTx)}</span></div>
        <div className="kpi k3">Categories<span className="n">{(catCount)}</span></div>
        <div className="kpi k1">Active Months<span className="n">{(activeMonths)}</span></div>
      </div>
      <div className="panel" style={{marginBottom:12}}>
        <div className="toolbar" style={{gap: 18}}>
          <div className="left" style={{display:'flex',alignItems:'center',gap:8}}>
            <input className="input-xs" type="text" placeholder="Search by name, amount, notes‚Ä¶" value={q} onChange={(e)=>setQ(e.target.value)}/>
            <button className="btn btn-xs" onClick={()=>setQ('')}>Clear</button>
          </div>
          <div className="middle" style={{display:'flex',alignItems:'center',gap:32,flexWrap:'wrap',minHeight:'64px'}}>
            {/* Primary and Secondary filter labels and controls in a single horizontal row, aligned with search */}
            <div style={{display:'flex',flexDirection:'row',alignItems:'center',gap:32}}>
              {/* Primary */}
              <div style={{display:'flex',flexDirection:'column',alignItems:'flex-start',justifyContent:'center'}}>
                <label style={{fontWeight:600,marginBottom:4,marginLeft:2}}>Primary</label>
                <div style={{display:'flex',gap:8,alignItems:'center'}}>
                  <select className="input-xs" style={{minWidth:120,height:'40px'}} value={filterCol} onChange={e=>setFilterCol(e.target.value)}>
                    <option value="">Filter by‚Ä¶</option>
                    <option value="tag">Tag</option>
                    <option value="name">Name</option>
                    <option value="category">Category</option>
                    <option value="subcategory">Sub-category</option>
                  </select>
                  {(filterCol === 'category' || filterCol === 'subcategory') ? (
                    <div style={{display:'flex',gap:4,alignItems:'center'}}>
                      <select className="input-xs" style={{minWidth:120,height:'40px'}} value={filterVal} onChange={e=>setFilterVal(e.target.value)} disabled={!filterCol}>
                        <option value="">All {filterCol}s</option>
                        {(filterCol === 'category' ? categoryOptions : subcategoryOptions).map(opt => 
                          <option key={opt} value={opt}>{opt}</option>
                        )}
                      </select>
                      <span style={{fontSize:'12px',color:'#6b7280'}}>or</span>
                      <input className="input-xs" style={{minWidth:80,height:'40px'}} type="text" placeholder="Type‚Ä¶" value={filterVal} onChange={e=>setFilterVal(e.target.value)} disabled={!filterCol}/>
                    </div>
                  ) : (
                    <input className="input-xs" style={{minWidth:120,height:'40px'}} type="text" placeholder="Value" value={filterVal} onChange={e=>setFilterVal(e.target.value)} disabled={!filterCol}/>
                  )}
                </div>
              </div>
              {/* Secondary */}
              <div style={{display:'flex',flexDirection:'column',alignItems:'flex-start',justifyContent:'center'}}>
                <label style={{fontWeight:600,marginBottom:4,marginLeft:2}}>Secondary</label>
                <div style={{display:'flex',gap:8,alignItems:'center'}}>
                  <select className="input-xs" style={{minWidth:120,height:'40px'}} value={filter2Col} onChange={e=>setFilter2Col(e.target.value)} disabled={!filterCol}>
                    <option value="">(optional)‚Ä¶</option>
                    <option value="tag">Tag</option>
                    <option value="name">Name</option>
                    <option value="category">Category</option>
                    <option value="subcategory">Sub-category</option>
                  </select>
                  {(filter2Col === 'category' || filter2Col === 'subcategory') ? (
                    <div style={{display:'flex',gap:4,alignItems:'center'}}>
                      <select className="input-xs" style={{minWidth:120,height:'40px'}} value={filter2Val} onChange={e=>setFilter2Val(e.target.value)} disabled={!filter2Col || !filterCol}>
                        <option value="">All {filter2Col}s</option>
                        {(filter2Col === 'category' ? categoryOptions : subcategoryOptions).map(opt => 
                          <option key={opt} value={opt}>{opt}</option>
                        )}
                      </select>
                      <span style={{fontSize:'12px',color:'#6b7280'}}>or</span>
                      <input className="input-xs" style={{minWidth:80,height:'40px'}} type="text" placeholder="Type‚Ä¶" value={filter2Val} onChange={e=>setFilter2Val(e.target.value)} disabled={!filter2Col || !filterCol}/>
                    </div>
                  ) : (
                    <input className="input-xs" style={{minWidth:120,height:'40px'}} type="text" placeholder="Second value" value={filter2Val} onChange={e=>setFilter2Val(e.target.value)} disabled={!filter2Col || !filterCol}/>
                  )}
                </div>
              </div>
            </div>
            {(filterCol||filterVal||filter2Col||filter2Val) && (
              <button
                className="btn btn-xs"
                style={{alignSelf:'center',marginLeft:8,marginBottom:0,height:'40px'}}
                onClick={() => {
                  setFilterCol(''); setFilterVal('');
                  setFilter2Col(''); setFilter2Val('');
                }}>
                Reset
              </button>
            )}
          </div>
            <div className="right">
              <button className="btn btn-xs primary" onClick={save} disabled={saving}>{saving?'Saving‚Ä¶':'üíæ Save Changes'}</button>
            </div>
          </div>
        </div>
      <div className="panel">
        <table>
          <thead><tr>
            <th className="nosort">‚úñ</th>
            {hdr('Tag','tag','w-tag')}
            {hdr('Date','date','w-date')}
            {hdr('Name','name','w-name')}
            {hdr('Transaction Amount','amount','w-amt')}
            {hdr('Debit Amount (ILS)','debit','w-debit')}
            {hdr('Type','type')}
            {hdr('Category','category','w-cat')}
            {hdr('Sub-category','subcategory','w-sub')}
            {hdr('Notes','notes','w-notes')}
            {hdr('Vi','vi')}
          </tr></thead>
          <tbody>
            {view.length? view.map((r,i)=>{
              const id=r.id||('p_'+i+'_'+(r.tag||'')+'_'+(r.date||'')+'_'+(r.name||'')); const currency=r.currency||'ILS';
              return (
                <tr key={id} className={r.vi?'row-vi':''}>
                  <td style={{width:48}}><button className="btn danger" onClick={()=>delRow(id)}>‚úñ</button></td>
                  <td className="w-tag">
                    <input 
                      type="number" 
                      value={r.month_tag || r.tag||''} 
                      onChange={(e)=>{
                        const newTag = Number(e.target.value||0);
                        patch(id,{tag:newTag, month_tag:newTag});
                      }}
                      title="Month (1-12)"
                    />
                  </td>
                  <td className="w-date">
                    <input 
                      type="text" 
                      placeholder="DD-MM-YYYY"
                      value={r.date_str || formatDMY(r.date_iso || r.date)} 
                      onChange={(e)=>{
                        const dmyValue = e.target.value;
                        const isoValue = parseDMYtoISO(dmyValue);
                        const d = dayjs(isoValue);
                        patch(id, {
                          date: isoValue,
                          date_iso: isoValue,
                          date_str: dmyValue,
                          year: d.isValid() ? d.year() : (r.year || dayjs().year()),
                          month_tag: d.isValid() ? d.month() + 1 : (r.month_tag || r.tag || 1),
                          tag: d.isValid() ? d.month() + 1 : (r.tag || 1)
                        });
                      }}
                    />
                  </td>
                  <td className="w-name" style={{textAlign:'center'}}>
                    <div className="cell-hscroll"><input className="fit" type="text" value={r.name||''} title={r.name||''} onChange={(e)=>patch(id,{name:e.target.value})}/></div>
                  </td>
                  <td className="w-amt">
                    <div style={{display:'flex',alignItems:'center',justifyContent:'center',gap:6}}>
                      {/* Use same currency symbol logic as TransactionsTab */}
                      {(() => {
                        const currencySymbols = { ILS: '‚Ç™', USD: '$', EUR: '‚Ç¨', GBP: '¬£' };
                        return <button className="currency-toggle" onClick={()=>toggleCurrency(id)}>{currencySymbols[currency] || currency}</button>;
                      })()}
                      <input
                        className="num-input"
                        type="text"
                        value={(r.amount_edit != null ? r.amount_edit : String(fmt2(r.amount)))}
                        onChange={(e)=>onAmountEditChange(id, e.target.value)}
                        onBlur={()=>onAmountEditBlur(id)}
                      />
                    </div>
                  </td>
                  <td className="w-debit">
                    <input
                      className="num-input"
                      type="text"
                      value={(r.debit_edit != null ? r.debit_edit : String(fmt2(r.debit)))}
                      onChange={(e)=>onDebitEditChange(id, e.target.value)}
                      onBlur={()=>onDebitEditBlur(id)}
                    />
                  </td>
                  <td><button className={'type-pill '+(r.type==='Expense'?'type-exp':'type-inc')} onClick={()=>toggleType(id)}>{r.type||'Expense'}</button></td>
                  <td className="w-cat"><select value={r.category||''} onChange={(e)=>patch(id,{category:e.target.value, subcategory:''})}><option value="">‚Äî Select ‚Äî</option>{Object.keys(categories||{}).sort((a,b)=>a.localeCompare(b)).map(c=><option key={c} value={c}>{c}</option>)}</select></td>
                  <td className="w-sub"><select value={r.subcategory||''} onChange={(e)=>patch(id,{subcategory:e.target.value})}><option value="">‚Äî Select ‚Äî</option>{((categories||{})[r.category]||[]).slice().sort((a,b)=>a.localeCompare(b)).map(s=><option key={s} value={s}>{s}</option>)}</select></td>
                  <td className="w-notes" style={{textAlign:'left'}}><input type="text" value={r.notes||''} onChange={(e)=>patch(id,{notes:e.target.value})}/></td>
                  <td><input type="checkbox" checked={!!r.vi} onChange={(e)=>patch(id,{vi:e.target.checked})}/></td>
                </tr>
              );
            }) : <tr><td colSpan="11" style={{textAlign:'center',color:'#6b7280'}}>No saved data yet.</td></tr>}
          </tbody>
        </table>
      </div>
    </React.Fragment>
  );
}

/* ---------- Summary (charts etc.) ---------- */
function SummaryTab({past,active}){
  const [err,setErr]=React.useState(''); const [selectedMonth,setSelectedMonth]=React.useState(''); const [subPieCat,setSubPieCat]=React.useState(''); const [expanded,setExpanded]=React.useState({});
  const [monthRangeStart, setMonthRangeStart] = React.useState(0); // Starting index for 6-month range
  const mRef=React.useRef(null), nRef=React.useRef(null), catRef=React.useRef(null), subRef=React.useRef(null);
  const mChart=React.useRef(null), nChart=React.useRef(null), catPie=React.useRef(null), subPie=React.useRef(null);
  // Updated aggregation: properly handle income and expense categories/subcategories with correct signs
  // Use tag/year combination as the key (e.g., "7/25" for July 2025)
  const agg=React.useMemo(()=>{
    var monthsSet={}, mio={}, mcdAll={};
    (past||[]).forEach(r=>{
      var tag=Number(r.tag||0)||Number(r.month_tag||0);
      var year=Number(r.year||dayjs().year());
      if(tag===0) return;
      
      // Create month key as "tag/year" (e.g., "7/25" for July 2025)
      var m = tag + '/' + String(year).slice(-2);
      var sortKey = year * 100 + tag; // For proper sorting (e.g., 202507 for July 2025)
      
      if(!monthsSet[m]) monthsSet[m] = sortKey;
      
      var d=Number(r.debit||0);
      var inc=String(r.type||'').toLowerCase()==='income';
      if(!mio[m]) mio[m]={income:0,outcome:0};
      if(inc) mio[m].income+=d; else mio[m].outcome+=d;
      // ---
      if(!mcdAll[m]) mcdAll[m]={};
      var cat=r.category||'Uncategorized', sub=r.subcategory||'‚Äî';
      
      // Initialize category structure properly for both income and expense tracking
      if(!mcdAll[m][cat]) mcdAll[m][cat]={
        total:0, 
        incomeTotal:0, 
        expenseTotal:0, 
        subcategories:{}, 
        type: inc ? 'Income' : 'Expense'
      };
      
      // Track both totals separately
      if(inc) {
        mcdAll[m][cat].incomeTotal += d;
      } else {
        mcdAll[m][cat].expenseTotal += d;
      }
      
      // Net total with correct signs: income positive, expense negative
      mcdAll[m][cat].total = mcdAll[m][cat].incomeTotal - mcdAll[m][cat].expenseTotal;
      
      // Set type based on which amount is larger
      if(mcdAll[m][cat].incomeTotal > mcdAll[m][cat].expenseTotal) {
        mcdAll[m][cat].type = 'Income';
      } else if(mcdAll[m][cat].expenseTotal > mcdAll[m][cat].incomeTotal) {
        mcdAll[m][cat].type = 'Expense';
      }
      
      if(!mcdAll[m][cat].subcategories[sub]) mcdAll[m][cat].subcategories[sub] = {total:0, incomeTotal:0, expenseTotal:0};
      
      if(inc) {
        mcdAll[m][cat].subcategories[sub].incomeTotal += d;
      } else {
        mcdAll[m][cat].subcategories[sub].expenseTotal += d;
      }
      // Net total with correct signs for subcategories too
      mcdAll[m][cat].subcategories[sub].total = mcdAll[m][cat].subcategories[sub].incomeTotal - mcdAll[m][cat].subcategories[sub].expenseTotal;
    });
    
    // Sort months by year and tag (chronologically)
    var months=Object.keys(monthsSet).sort((a,b)=> monthsSet[a] - monthsSet[b]);
    
    var monthNet={};
    months.forEach(m=>{
      var io=mio[m]||{income:0,outcome:0};
      monthNet[m]={net:(io.income-io.outcome),income:io.income,outcome:io.outcome};
    });
    var outTotals=months.map(m=> (mio[m]&&mio[m].outcome)||0 );
    return {months, mcdAll, monthNet, outTotals};
  },[past]);
  const months=agg.months, monthCategoryDataAll=agg.mcdAll, monthNet=agg.monthNet, outTotals=agg.outTotals;
  
  // Calculate visible months (last 6 or all if fewer than 6)
  const maxDisplayMonths = 6;
  const totalMonths = months.length;
  const displayMonths = React.useMemo(() => {
    if (totalMonths <= maxDisplayMonths) {
      return months; // Show all months if 6 or fewer
    }
    
    // Calculate the slice based on monthRangeStart
    const startIdx = Math.max(0, Math.min(monthRangeStart, totalMonths - maxDisplayMonths));
    return months.slice(startIdx, startIdx + maxDisplayMonths);
  }, [months, monthRangeStart, totalMonths]);
  
  // Update monthRangeStart to show most recent months by default
  React.useEffect(() => {
    if (totalMonths > maxDisplayMonths && monthRangeStart === 0) {
      setMonthRangeStart(totalMonths - maxDisplayMonths);
    }
  }, [totalMonths, monthRangeStart]);
  
  const canNavigatePrev = monthRangeStart > 0;
  const canNavigateNext = monthRangeStart < totalMonths - maxDisplayMonths;
  React.useEffect(()=>{ try{ if(!months.length){ setSelectedMonth(''); setSubPieCat(''); return; } var def=selectedMonth&&months.includes(selectedMonth)?selectedMonth:months[months.length-1]; setSelectedMonth(def); var cats=Object.keys(monthCategoryDataAll[def]||{}); setSubPieCat(prev=> (prev && cats.includes(prev))?prev:(cats[0]||'')); }catch(e){ setErr('Init error: '+e.message);} },[months.join(','), JSON.stringify(monthCategoryDataAll)]);
  React.useEffect(()=>{ try{
    if(!active) return;
    [mChart,nChart,catPie,subPie].forEach(R=>{ if(R.current && typeof R.current.destroy==='function'){ try{R.current.destroy();}catch(_){ } R.current=null; }});
    if(!months.length) return;
    var ChartLib=window.Chart, DLabels=window.ChartDataLabels; if(DLabels && !window.__mtDLReg){ ChartLib.register(DLabels); window.__mtDLReg=true; }
    const common={responsive:true, maintainAspectRatio:false};
    if(mRef.current){
      const ctx=mRef.current.getContext('2d');
      mChart.current=new ChartLib(ctx,{
        type:'bar',
        data:{labels:months,datasets:[{label:'Monthly Outcome (‚Ç™)',data:outTotals}]},
        options:Object.assign({},common,{
          plugins:{
            legend:{display:false},
            datalabels:DLabels?{
              formatter:(v)=>fmt2(v),
              anchor:'end',align:'top',clamp:true
            }:{}
          },
          scales:{y:{beginAtZero:true}}
        })
      });
    }
    if(nRef.current){
      const ctx=nRef.current.getContext('2d');
      const nvals=months.map(m=>(monthNet[m]&&monthNet[m].net)||0);
      nChart.current=new ChartLib(ctx,{
        type:'bar',
        data:{labels:months,datasets:[{label:'Net (‚Ç™)',data:nvals}]},
        options:Object.assign({},common,{
          plugins:{
            legend:{display:false},
            datalabels:DLabels?{
              formatter:(v)=>fmt2(v),
              anchor:'end',align:'top',clamp:true
            }:{}
          }
        })
      });
    }
    const piePlugins={legend:{position:'right'}, datalabels:{display:false}};
    // Custom tooltip with percentage on new line
    function pieTooltipCallback(context) {
      const label = context.label || '';
      const value = context.parsed || 0;
      const dataArr = context.chart.data.datasets[0].data;
      const total = dataArr.reduce((a,b)=>a+b,0);
      const percent = total ? (value/total*100) : 0;
      return [label + ': ' + fmt2(value), fmt2(percent) + '%'];
    }
    const pieOptionsWithPct = Object.assign({}, common, {
      plugins: Object.assign({}, piePlugins, {
        tooltip: {
          callbacks: {
            label: pieTooltipCallback
          }
        }
      })
    });
    if(selectedMonth && catRef.current){
      const ctx=catRef.current.getContext('2d');
      const mcd=monthCategoryDataAll[selectedMonth]||{};
      // Only outcome (expense) categories
      const labels=Object.keys(mcd).filter(k=>(mcd[k].type||'Expense')==='Expense');
      const data=labels.map(k=>mcd[k].total);
      catPie.current=new ChartLib(ctx,{
        type:'pie',
        data:{labels,datasets:[{data}]},
        options: pieOptionsWithPct
      });
    }
    if(selectedMonth && subPieCat && subRef.current){
      const ctx=subRef.current.getContext('2d');
      const mcd=monthCategoryDataAll[selectedMonth]||{};
      // Only show subcategories if parent is outcome (expense)
      if (mcd[subPieCat] && (mcd[subPieCat].type||'Expense')==='Expense') {
        const subs=(mcd[subPieCat]&&mcd[subPieCat].subcategories)||{};
        const labels=Object.keys(subs);
        const data=labels.map(k=>{
          const subData = subs[k];
          return typeof subData === 'number' ? subData : subData.total;
        });
        subPie.current=new ChartLib(ctx,{
          type:'pie',
          data:{labels,datasets:[{data}]},
          options: pieOptionsWithPct
        });
      } else {
        // If not expense, show empty pie
        subPie.current=new ChartLib(ctx,{
          type:'pie',
          data:{labels:[],datasets:[{data:[]}]},
          options: pieOptionsWithPct
        });
      }
    }
  }catch(e){ setErr('Chart error: '+e.message); } },[active, months.join(','), selectedMonth, subPieCat, JSON.stringify(monthCategoryDataAll), JSON.stringify(monthNet)]);
  if(!(past||[]).length) return <div className="panel"><div>No data available. Upload data first.</div></div>;
  const monthCats=Object.keys(monthCategoryDataAll[selectedMonth]||{}).sort((a,b)=>a.localeCompare(b));
  React.useEffect(()=>{ if(!selectedMonth) return; if(!monthCats.length){ setSubPieCat(''); return; } if(!subPieCat || !monthCats.includes(subPieCat)) setSubPieCat(monthCats[0]); },[selectedMonth, monthCats.join(',')]);
  return (
    <div className="panel">
      {err && <div className="panel" style={{background:'#fff7ed',border:'1px solid #fcd19c',color:'#92400e'}}>‚ö†Ô∏è {err}</div>}
      <div className="section-title">üìÖ Comparison Across Months</div>
      {totalMonths > maxDisplayMonths && (
        <div className="controls" style={{marginBottom:10}}>
          <button 
            className="btn btn-xs" 
            onClick={() => setMonthRangeStart(Math.max(0, monthRangeStart - 1))}
            disabled={!canNavigatePrev}
          >
            ‚Üê Previous Month
          </button>
          <span className="muted" style={{margin: '0 12px'}}>
            Showing months {displayMonths[0]} to {displayMonths[displayMonths.length-1]} 
            ({displayMonths.length} of {totalMonths} total)
          </span>
          <button 
            className="btn btn-xs" 
            onClick={() => setMonthRangeStart(Math.min(totalMonths - maxDisplayMonths, monthRangeStart + 1))}
            disabled={!canNavigateNext}
          >
            Next Month ‚Üí
          </button>
          <button 
            className="btn btn-xs" 
            onClick={() => setMonthRangeStart(totalMonths - Math.min(maxDisplayMonths, totalMonths))}
            style={{marginLeft: 8}}
          >
            Latest
          </button>
        </div>
      )}
      <div style={{overflowX:'auto'}}>
        <table>
          <thead><tr><th>Category</th>{displayMonths.map(m=><th key={'h'+m}>{m}</th>)}</tr></thead>
          <tbody>
            {(function(){
              // Show all categories (income and expense) that have data in displayed months
              const allCats=(function(){ 
                var s={}; 
                displayMonths.forEach(mm=>{ 
                  if (monthCategoryDataAll[mm]) {
                    Object.keys(monthCategoryDataAll[mm]).forEach(c=>s[c]=1); 
                  }
                }); 
                return Object.keys(s).sort((a,b)=>a.localeCompare(b)); 
              })();
              if(!allCats.length) return <tr><td colSpan={displayMonths.length+1} className="muted" style={{textAlign:'center'}}>No categories yet.</td></tr>;
              return allCats.filter(cat => {
                // Hide category if it has no data (all zeros/dashes) across displayed months
                const hasData = displayMonths.some(m => {
                  const cell = monthCategoryDataAll[m] && monthCategoryDataAll[m][cat];
                  return cell && cell.total !== 0;
                });
                return hasData;
              }).map(cat=>{
                const exp=!!expanded[cat];
                return (
                  <React.Fragment key={cat}>
                    <tr>
                      <td><button className="btn btn-xs" onClick={()=>setExpanded(p=>Object.assign({},p,{[cat]:!p[cat]}))}>{exp?'‚ñæ':'‚ñ∏'}</button> <strong>{cat}</strong></td>
                      {displayMonths.map(m=>{ 
                        const cell=monthCategoryDataAll[m]&&monthCategoryDataAll[m][cat]; 
                        const v=cell?cell.total:0; 
                        const isPositive = v > 0;
                        const displayValue = v !== 0 ? (isPositive ? '+' : '') + '‚Ç™' + fmt2(Math.abs(v)) : '‚Äî';
                        return <td key={cat+'_'+m}><strong style={{color: v > 0 ? '#16a34a' : v < 0 ? '#dc2626' : 'inherit'}}>{displayValue}</strong></td>; 
                      })}
                    </tr>
                    {exp && (function(){
                      var subsSet={}; displayMonths.forEach(m=>{ var cell=monthCategoryDataAll[m]&&monthCategoryDataAll[m][cat]; if(cell){ Object.keys(cell.subcategories||{}).forEach(s=>subsSet[s]=1); }});
                      var subs=Object.keys(subsSet).sort((a,b)=>a.localeCompare(b));
                      // Hide subcategories that have no data across displayed months
                      return subs.filter(s => {
                        const hasData = displayMonths.some(m => {
                          var cell=monthCategoryDataAll[m]&&monthCategoryDataAll[m][cat];
                          var subData=cell?(cell.subcategories[s]||{total:0}):0;
                          var v = typeof subData === 'number' ? subData : subData.total;
                          return v !== 0;
                        });
                        return hasData;
                      }).map(s=>(
                        <tr key={cat+'__'+s}>
                          <td className="muted" style={{paddingLeft:42}}>‚Ü≥ {s}</td>
                          {displayMonths.map(m=>{
                            var cell=monthCategoryDataAll[m]&&monthCategoryDataAll[m][cat];
                            var subData=cell?(cell.subcategories[s]||{total:0}):0;
                            var v = typeof subData === 'number' ? subData : subData.total;
                            const isPositive = v > 0;
                            const displayValue = v !== 0 ? (isPositive ? '+' : '') + '‚Ç™' + fmt2(Math.abs(v)) : '‚Äî';
                            return <td key={cat+'_'+s+'_'+m} style={{color: v > 0 ? '#16a34a' : v < 0 ? '#dc2626' : 'inherit'}}>{displayValue}</td>;
                          })}
                        </tr>
                      ));
                    })()}
                  </React.Fragment>
                );
              });
            })()}
            <tr style={{
              borderTop: '4px double #6b46c1',
              borderBottom: '4px double #6b46c1',
              backgroundColor: '#fde047',
              boxShadow: '0 4px 12px rgba(234, 179, 8, 0.3)',
              transform: 'scale(1.01)'
            }}>
              <td style={{backgroundColor: '#fde047', padding: '14px'}}><strong style={{fontSize: '17px', fontWeight: '800', color: '#1f1b2e'}}>Net (Income ‚àí Expenses)</strong></td>
              {displayMonths.map(m=> {
                const netValue = Number((monthNet[m]&&monthNet[m].net)||0);
                const isPositive = netValue > 0;
                const displayValue = netValue !== 0 ? (isPositive ? '+' : '') + '‚Ç™' + fmt2(Math.abs(netValue)) : '‚Ç™0.00';
                return <td key={'net_'+m} style={{backgroundColor: '#fde047', padding: '14px'}}><strong style={{
                  fontSize: '16px',
                  fontWeight: '800',
                  color: netValue > 0 ? '#16a34a' : netValue < 0 ? '#dc2626' : '#6b7280'
                }}>{displayValue}</strong></td>;
              })}
            </tr>
          </tbody>
        </table>
      </div>

      <div className="grid-2" style={{marginTop:14}}>
        <div className="panel"><div className="section-title" style={{marginTop:0}}>üìä Monthly Outcome (‚Ç™)</div><div className="chart-box"><canvas ref={mRef}></canvas></div></div>
        <div className="panel"><div className="section-title" style={{marginTop:0}}>üìà Monthly Net (‚Ç™)</div><div className="chart-box"><canvas ref={nRef}></canvas></div></div>
      </div>

      <div className="section-title">üîé Details for Month</div>
      <div className="controls" style={{marginBottom:10}}>
        <select value={selectedMonth} onChange={(e)=>setSelectedMonth(e.target.value)}>{months.map(m=><option key={'m'+m} value={m}>{m}</option>)}</select>
        <span className="muted">Select month (tag) to focus below</span>
      </div>

      <div style={{overflowX:'auto', marginBottom:14}}>
        <table>
          <thead><tr><th>Category</th><th>Total (‚Ç™)</th></tr></thead>
          <tbody>
            {Object.keys(monthCategoryDataAll[selectedMonth]||{}).length? Object.keys(monthCategoryDataAll[selectedMonth]).sort((a,b)=>a.localeCompare(b)).map(cat=>{
              const cell=monthCategoryDataAll[selectedMonth][cat]||{total:0,subcategories:{}}; const subs=cell.subcategories||{}; const total=cell.total||0; const key='m_'+selectedMonth+'_'+cat; const exp=!!expanded[key];
              return (
                <React.Fragment key={'mrow_'+cat}>
                  <tr>
                    <td><button className="btn btn-xs" onClick={()=>setExpanded(p=>Object.assign({},p,{[key]:!p[key]}))}>{exp?'‚ñæ':'‚ñ∏'}</button> <strong>{cat}</strong></td>
                    <td><strong style={{color: total > 0 ? '#16a34a' : total < 0 ? '#dc2626' : 'inherit'}}>
                      {total !== 0 ? (total > 0 ? '+' : '') + '‚Ç™' + fmt2(Math.abs(total)) : '‚Ç™0.00'}
                    </strong></td>
                  </tr>
                  {exp && Object.keys(subs).sort((a,b)=>a.localeCompare(b)).map(s=>{
                    var subData = subs[s];
                    var subValue = typeof subData === 'number' ? subData : subData.total;
                    const displayValue = subValue !== 0 ? (subValue > 0 ? '+' : '') + '‚Ç™' + fmt2(Math.abs(subValue)) : '‚Ç™0.00';
                    return <tr key={'mrow_'+cat+'_'+s}><td className="muted" style={{paddingLeft:42}}>‚Ü≥ {s}</td><td style={{color: subValue > 0 ? '#16a34a' : subValue < 0 ? '#dc2626' : 'inherit'}}>{displayValue}</td></tr>;
                  })}
                </React.Fragment>
              );
            }) : <tr><td colSpan="2" style={{textAlign:'center'}} className="muted">No categories in this month.</td></tr>}
            {selectedMonth && (monthNet[selectedMonth] || Object.keys(monthCategoryDataAll[selectedMonth]||{}).length) && (
              <tr style={{borderTop: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                <td><strong>Net (Income - Expenses)</strong></td>
                <td><strong style={{color: (monthNet[selectedMonth]&&monthNet[selectedMonth].net||0) > 0 ? '#16a34a' : (monthNet[selectedMonth]&&monthNet[selectedMonth].net||0) < 0 ? '#dc2626' : 'inherit'}}>
                  {(() => {
                    const netValue = Number((monthNet[selectedMonth]&&monthNet[selectedMonth].net)||0);
                    return netValue !== 0 ? (netValue > 0 ? '+' : '') + '‚Ç™' + fmt2(Math.abs(netValue)) : '‚Ç™0.00';
                  })()}
                </strong></td>
              </tr>
            )}
          </tbody>
        </table>
      </div>

      <div className="controls" style={{marginBottom:10}}>
        <span className="muted">Sub-category pie for category:</span>
        <select value={subPieCat} onChange={(e)=>setSubPieCat(e.target.value)}>
          {monthCats.filter(c => {
            const mcd = monthCategoryDataAll[selectedMonth] || {};
            return mcd[c] && (mcd[c].type || 'Expense') === 'Expense';
          }).map(c => <option key={'spc_'+c} value={c}>{c}</option>)}
        </select>
      </div>

      <div className="grid-2">
        <div className="panel"><div className="section-title" style={{marginTop:0}}>üß© Categories (Outcome)</div><div className="chart-box"><canvas ref={catRef}></canvas></div></div>
        <div className="panel"><div className="section-title" style={{marginTop:0}}>üç∞ Sub-categories ‚Äî {subPieCat || '‚Äî'}</div><div className="chart-box"><canvas ref={subRef}></canvas></div></div>
      </div>
    </div>
  );
}

/* ---------- Statistics Tab ---------- */
function StatisticsTab({past, categories}){
  // Filter state
  const [selectedTags, setSelectedTags] = React.useState([]);
  const [selectedYears, setSelectedYears] = React.useState([]);
  const [selectedCategory, setSelectedCategory] = React.useState('');
  const [selectedSubcategories, setSelectedSubcategories] = React.useState([]);
  const [typeFilter, setTypeFilter] = React.useState('Expense'); // 'All' | 'Expense' | 'Income'
  
  // Statistics data
  const [summary, setSummary] = React.useState({mean:0, max:0, min:0, count:0});
  const [perTagMeans, setPerTagMeans] = React.useState({per_tag:[], combined_mean:0});
  const [categoryLast3, setCategoryLast3] = React.useState({data:[]});
  const [incomeMeans, setIncomeMeans] = React.useState({breakdown:[], overall_mean:0});
  const [rollup, setRollup] = React.useState({data:[]});
  
  // Available options from data
  const availableTags = React.useMemo(() => {
    const tags = new Set();
    (past || []).forEach(tx => {
      const tag = tx.month_tag || tx.tag;
      if (tag) tags.add(tag);
    });
    return Array.from(tags).sort((a,b) => a-b);
  }, [past]);
  
  const availableYears = React.useMemo(() => {
    const years = new Set();
    (past || []).forEach(tx => {
      const year = tx.year;
      if (year) years.add(year);
    });
    return Array.from(years).sort((a,b) => a-b);
  }, [past]);
  
  const categoryOptions = React.useMemo(() => {
    return Object.keys(categories || {}).sort();
  }, [categories]);
  
  const subcategoryOptions = React.useMemo(() => {
    if (!selectedCategory || !categories[selectedCategory]) return [];
    return categories[selectedCategory];
  }, [selectedCategory, categories]);
  
  // Quick filter presets
  function quickFilterLast3Months() {
    const sorted = availableTags.slice().sort((a,b) => b-a);
    setSelectedTags(sorted.slice(0, 3));
  }
  
  function quickFilterLast6Months() {
    const sorted = availableTags.slice().sort((a,b) => b-a);
    setSelectedTags(sorted.slice(0, 6));
  }
  
  function quickFilterYTD() {
    const currentYear = new Date().getFullYear();
    const currentMonth = new Date().getMonth() + 1;
    setSelectedYears([currentYear]);
    const ytdTags = availableTags.filter(t => t <= currentMonth);
    setSelectedTags(ytdTags);
  }
  
  // Build filter object for API calls
  const filters = React.useMemo(() => ({
    tags: selectedTags,
    years: selectedYears,
    category: selectedCategory,
    subcategories: selectedSubcategories,
    type: typeFilter
  }), [selectedTags, selectedYears, selectedCategory, selectedSubcategories, typeFilter]);
  
  // Fetch statistics when filters change
  React.useEffect(() => {
    if (!past || past.length === 0) return;
    
    // Fetch summary (Mean, Max, Min)
    API.statsSummary(filters).then(setSummary).catch(e => console.error('Stats summary error:', e));
    
    // Fetch per-tag means (bar chart)
    API.statsPerTagMeans(filters).then(setPerTagMeans).catch(e => console.error('Stats per tag error:', e));
    
    // Fetch category last 3 months (if category selected)
    if (selectedCategory) {
      API.statsCategoryLast3({category: selectedCategory}).then(setCategoryLast3).catch(e => console.error('Stats cat last3 error:', e));
    }
    
    // Fetch income means
    if (typeFilter === 'Income' || typeFilter === 'All') {
      API.statsIncomeMeans({tags: selectedTags, years: selectedYears}).then(setIncomeMeans).catch(e => console.error('Stats income error:', e));
    }
    
    // Fetch rollup table
    API.statsRollup(filters).then(setRollup).catch(e => console.error('Stats rollup error:', e));
  }, [JSON.stringify(filters), past.length]);
  
  // Toggle tag selection
  function toggleTag(tag) {
    setSelectedTags(prev => 
      prev.includes(tag) ? prev.filter(t => t !== tag) : [...prev, tag]
    );
  }
  
  // Toggle year selection
  function toggleYear(year) {
    setSelectedYears(prev => 
      prev.includes(year) ? prev.filter(y => y !== year) : [...prev, year]
    );
  }
  
  // Export statistics to CSV
  function exportCSV() {
    const rows = [
      ['MoneyTron Statistics Export'],
      ['Generated:', new Date().toISOString()],
      [''],
      ['Filters:'],
      ['Tags:', selectedTags.join(', ') || 'All'],
      ['Years:', selectedYears.join(', ') || 'All'],
      ['Category:', selectedCategory || 'All'],
      ['Type:', typeFilter],
      [''],
      ['Summary Statistics:'],
      ['Mean', 'Max', 'Min', 'Count'],
      [summary.mean.toFixed(2), summary.max.toFixed(2), summary.min.toFixed(2), summary.count],
      [''],
      ['Per-Tag Means:'],
      ['Tag', 'Mean', 'Count'],
      ...perTagMeans.per_tag.map(item => [item.tag, item.mean.toFixed(2), item.count]),
      ['Combined Mean', perTagMeans.combined_mean.toFixed(2), ''],
      [''],
      ['Rollup Table:'],
      ['Year', 'Tag', 'Total', 'Mean', 'Count'],
      ...rollup.data.map(item => [item.year, item.tag, item.total.toFixed(2), item.mean.toFixed(2), item.count])
    ];
    
    const csv = rows.map(row => row.join(',')).join('\n');
    const blob = new Blob([csv], {type: 'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `moneytron_statistics_${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }
  
  if (!past || past.length === 0) {
    return (
      <div className="panel">
        <div className="section-title">üìä Statistics Dashboard</div>
        <div className="muted">No transaction data available. Upload data first in the Transactions or Data tabs.</div>
      </div>
    );
  }
  
  return (
    <React.Fragment>
      <div className="section-title">üìä Statistics Dashboard</div>
      <div className="section-sub">Analyze your financial data with powerful filtering and insights.</div>
      
      {/* Sticky Filter Bar */}
      <div className="panel" style={{marginBottom: 14, position: 'sticky', top: 0, zIndex: 10, backgroundColor: 'rgba(255,255,255,0.95)', backdropFilter: 'blur(8px)'}}>
        <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: 12, marginBottom: 12}}>
          {/* Tags (Months) Filter */}
          <div>
            <label style={{fontWeight: 700, display: 'block', marginBottom: 6}}>Tags (Months)</label>
            <div style={{display: 'flex', flexWrap: 'wrap', gap: 6}}>
              {availableTags.map(tag => (
                <button
                  key={tag}
                  className={'btn btn-xs ' + (selectedTags.includes(tag) ? 'primary' : '')}
                  onClick={() => toggleTag(tag)}
                  style={{minWidth: 40}}
                >
                  {tag}
                </button>
              ))}
            </div>
          </div>
          
          {/* Years Filter */}
          <div>
            <label style={{fontWeight: 700, display: 'block', marginBottom: 6}}>Years</label>
            <div style={{display: 'flex', flexWrap: 'wrap', gap: 6}}>
              {availableYears.map(year => (
                <button
                  key={year}
                  className={'btn btn-xs ' + (selectedYears.includes(year) ? 'primary' : '')}
                  onClick={() => toggleYear(year)}
                >
                  {year}
                </button>
              ))}
            </div>
          </div>
          
          {/* Category Filter */}
          <div>
            <label style={{fontWeight: 700, display: 'block', marginBottom: 6}}>Category</label>
            <select 
              value={selectedCategory} 
              onChange={(e) => {setSelectedCategory(e.target.value); setSelectedSubcategories([]);}}
              style={{width: '100%'}}
            >
              <option value="">All Categories</option>
              {categoryOptions.map(cat => (
                <option key={cat} value={cat}>{cat}</option>
              ))}
            </select>
          </div>
          
          {/* Subcategory Filter */}
          <div>
            <label style={{fontWeight: 700, display: 'block', marginBottom: 6}}>Subcategory</label>
            <select 
              value={selectedSubcategories[0] || ''} 
              onChange={(e) => setSelectedSubcategories(e.target.value ? [e.target.value] : [])}
              disabled={!selectedCategory}
              style={{width: '100%'}}
            >
              <option value="">All Subcategories</option>
              {subcategoryOptions.map(sub => (
                <option key={sub} value={sub}>{sub}</option>
              ))}
            </select>
          </div>
          
          {/* Type Toggle */}
          <div>
            <label style={{fontWeight: 700, display: 'block', marginBottom: 6}}>Type</label>
            <div style={{display: 'flex', gap: 6}}>
              {['All', 'Expense', 'Income'].map(type => (
                <button
                  key={type}
                  className={'btn btn-xs ' + (typeFilter === type ? 'primary' : '')}
                  onClick={() => setTypeFilter(type)}
                >
                  {type}
                </button>
              ))}
            </div>
          </div>
        </div>
        
        {/* Quick Filters */}
        <div style={{display: 'flex', gap: 8, alignItems: 'center', paddingTop: 8, borderTop: '1px solid #e5e7eb'}}>
          <span style={{fontWeight: 600, marginRight: 8}}>Quick Filters:</span>
          <button className="btn btn-xs ghost" onClick={quickFilterLast3Months}>Last 3 Months</button>
          <button className="btn btn-xs ghost" onClick={quickFilterLast6Months}>Last 6 Months</button>
          <button className="btn btn-xs ghost" onClick={quickFilterYTD}>YTD</button>
          <button className="btn btn-xs ghost" onClick={() => {setSelectedTags([]); setSelectedYears([]); setSelectedCategory(''); setSelectedSubcategories([]); setTypeFilter('Expense');}}>Clear All</button>
          <div style={{flex: 1}}></div>
          <button className="btn btn-xs primary" onClick={exportCSV}>üìä Export CSV</button>
        </div>
      </div>
      
      {/* KPI Cards: Mean, Max, Min */}
      <div className="kpis">
        <div className="kpi k1">
          Mean Amount
          <span className="n">‚Ç™{fmt2(summary.mean)}</span>
        </div>
        <div className="kpi k2">
          Max Amount
          <span className="n">‚Ç™{fmt2(summary.max)}</span>
        </div>
        <div className="kpi k3">
          Min Amount
          <span className="n">‚Ç™{fmt2(summary.min)}</span>
        </div>
        <div className="kpi k4">
          Transactions
          <span className="n">{summary.count}</span>
        </div>
      </div>
      
      {/* Per-Tag Means (Bar Chart) */}
      {selectedTags.length > 0 && (
        <div className="panel" style={{marginBottom: 14}}>
          <div className="section-title">üìä Mean of {typeFilter === 'All' ? 'Transactions' : typeFilter + 's'} Across Selected Months</div>
          <div style={{overflowX: 'auto'}}>
            <table>
              <thead>
                <tr>
                  <th>Tag</th>
                  <th>Mean (‚Ç™)</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody>
                {perTagMeans.per_tag.map(item => (
                  <tr key={item.tag}>
                    <td><strong>{item.tag}</strong></td>
                    <td>‚Ç™{fmt2(item.mean)}</td>
                    <td>{item.count}</td>
                  </tr>
                ))}
                <tr style={{borderTop: '2px solid #6b46c1', backgroundColor: '#f3f4f6'}}>
                  <td><strong>Combined Mean</strong></td>
                  <td><strong>‚Ç™{fmt2(perTagMeans.combined_mean)}</strong></td>
                  <td>‚Äî</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      )}
      
      {/* Category Last 3 Months */}
      {selectedCategory && categoryLast3.data.length > 0 && (
        <div className="panel" style={{marginBottom: 14}}>
          <div className="section-title">üìà Mean of "{selectedCategory}" (Last 3 Months)</div>
          <div style={{overflowX: 'auto'}}>
            <table>
              <thead>
                <tr>
                  <th>Month Tag</th>
                  <th>Mean (‚Ç™)</th>
                </tr>
              </thead>
              <tbody>
                {categoryLast3.data.map(item => (
                  <tr key={item.tag}>
                    <td>{item.tag}</td>
                    <td>‚Ç™{fmt2(item.mean)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
      
      {/* Income Means */}
      {(typeFilter === 'Income' || typeFilter === 'All') && incomeMeans.breakdown.length > 0 && (
        <div className="panel" style={{marginBottom: 14}}>
          <div className="section-title">üí∞ Mean of Incomes</div>
          <div className="kpis" style={{marginBottom: 12}}>
            <div className="kpi k2">
              Overall Income Mean
              <span className="n">‚Ç™{fmt2(incomeMeans.overall_mean)}</span>
            </div>
          </div>
          <div style={{overflowX: 'auto'}}>
            <table>
              <thead>
                <tr>
                  <th>Category</th>
                  <th>Subcategory</th>
                  <th>Mean (‚Ç™)</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody>
                {incomeMeans.breakdown.map((item, idx) => (
                  <tr key={idx}>
                    <td>{item.category}</td>
                    <td>{item.subcategory}</td>
                    <td>‚Ç™{fmt2(item.mean)}</td>
                    <td>{item.count}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
      
      {/* Rollup Table */}
      {rollup.data.length > 0 && (
        <div className="panel">
          <div className="section-title">üìã {typeFilter === 'All' ? 'All' : typeFilter} Transactions Rollup</div>
          <div style={{overflowX: 'auto'}}>
            <table>
              <thead>
                <tr>
                  <th>Year</th>
                  <th>Tag</th>
                  <th>Total (‚Ç™)</th>
                  <th>Mean (‚Ç™)</th>
                  <th>Count</th>
                </tr>
              </thead>
              <tbody>
                {rollup.data.map((item, idx) => (
                  <tr key={idx}>
                    <td>{item.year}</td>
                    <td>{item.tag}</td>
                    <td>‚Ç™{fmt2(item.total)}</td>
                    <td>‚Ç™{fmt2(item.mean)}</td>
                    <td>{item.count}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </React.Fragment>
  );
}

/* ---------- Settings (renamed, but keeping for backward compatibility - will be hidden) ---------- */
function SettingsTab({ user, past, categories, stage, settings, onReload }){
  const [dateFormat, setDateFormat] = React.useState(settings.dateFormat || 'YYYY-MM-DD');
  const [currency, setCurrency] = React.useState(settings.currency || 'ILS');
  const [allowedCurrencies, setAllowedCurrencies] = React.useState(settings.allowedCurrencies || ["ILS","USD"]);
  const allCurrencies = ["ILS","USD","EUR","GBP"];
  React.useEffect(()=>{
    setDateFormat(settings.dateFormat||'YYYY-MM-DD');
    setCurrency(settings.currency||'ILS');
    setAllowedCurrencies(settings.allowedCurrencies||["ILS","USD"]);
  },[settings.dateFormat,settings.currency,settings.allowedCurrencies]);

  function toggleAllowedCurrency(cur) {
    setAllowedCurrencies(prev => prev.includes(cur) ? prev.filter(c=>c!==cur) : [...prev, cur]);
  }

  function savePrefs(){
    API.saveSettings({dateFormat,currency,allowedCurrencies}).then(()=>{
      alert('Preferences saved.');
      if (typeof onReload === 'function') onReload(); // reload app state (settings)
    });
  }
  function exportAll(){
    const payload={ user, categories, past_data: past, current_month:stage, settings:{dateFormat,currency,allowedCurrencies,theme:settings.theme||'light'} };
    const blob=new Blob([JSON.stringify(payload,null,2)],{type:'application/json'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`moneytron_${user}_export.json`; a.click(); URL.revokeObjectURL(a.href);
  }
  function onImport(e){
    const f=e.target.files&&e.target.files[0]; if(!f) return;
    const reader=new FileReader(); reader.onload=function(){ try{ const data=JSON.parse(reader.result); API.importData({categories:data.categories,past_data:data.past_data,current_month:data.current_month,settings:data.settings}).then(()=>{ alert('Imported successfully.'); onReload&&onReload(); }); }catch(err){ alert('Invalid file: '+err.message);} };
    reader.readAsText(f,'utf-8'); e.target.value='';
  }
  function clearAll(){ if(!confirm('Clear ALL data for this user? This cannot be undone.')) return; API.clearAll().then(()=>{ alert('All user data cleared.'); onReload&&onReload(); }); }

  // Simple account info
  const monthsSet={}; let lastTxVar=null, totalSpending=0;
  (past||[]).forEach(r=>{ const d=Number(r.debit||0); if(String(r.type||'').toLowerCase()!=='income') totalSpending+=d; const m=Number(r.tag||0); if(m>0) monthsSet[m]=1; if(r.date){ if(!lastTxVar || dayjs(r.date).isAfter(dayjs(lastTxVar.date))) lastTxVar=r; }});
  const avgMonthly=Object.keys(monthsSet).length? totalSpending/Object.keys(monthsSet).length : 0;
  const lastTxLabel=lastTxVar ? `${lastTxVar.date} ‚Äî ${lastTxVar.name}` : 'No transactions yet';

  return (
    <div className="panel">
      <div className="section-title">‚öôÔ∏è Settings &amp; Profile for {user}</div>
      <div className="thin-underline"></div>
      <div className="section-sub">Manage your account, data, and application preferences.</div>

      <div className="grid-2">
        <div className="panel">
          <div className="section-title">üóÇÔ∏è Data Management</div>
          <div className="dm-grid">
            <div className="dm-left">
              <button className="btn" onClick={exportAll}>‚¨áÔ∏è Export All Data</button>
              <label className="btn">üì® Import Data<input type="file" accept="application/json,.json" style={{display:'none'}} onChange={onImport}/></label>
            </div>
            <div className="dm-right">
              <button className="btn danger" onClick={clearAll}>üßπ Clear All Data</button>
              <div className="danger-caption">‚ö†Ô∏è This action cannot be undone.</div>
            </div>
          </div>
        </div>

        <div className="panel">
          <div className="section-title">üß© Preferences</div>
          <div className="controls" style={{flexDirection:'column', alignItems:'stretch'}}>
            <label>Date Format</label>
            <select value={dateFormat} onChange={(e)=>setDateFormat(e.target.value)}>
              <option value="YYYY-MM-DD">YYYY-MM-DD ({dayjs().format('YYYY-MM-DD')})</option>
              <option value="DD/MM/YYYY">DD/MM/YYYY ({dayjs().format('DD/MM/YYYY')})</option>
              <option value="MM/DD/YYYY">MM/DD/YYYY ({dayjs().format('MM/DD/YYYY')})</option>
            </select>
            <label style={{marginTop:8}}>Default Currency</label>
            <select value={currency} onChange={(e)=>setCurrency(e.target.value)}>
              {allCurrencies.map(cur=>(<option key={cur} value={cur}>{cur}</option>))}
            </select>
            <label style={{marginTop:8}}>Allowed Currencies for Toggling</label>
            <div style={{display:'flex',gap:8,marginTop:4,marginBottom:8}}>
              {allCurrencies.map(cur=>(
                <button key={cur} className={"currency-toggle"+(allowedCurrencies.includes(cur)?" active":"")} type="button" onClick={()=>toggleAllowedCurrency(cur)} style={{fontWeight:allowedCurrencies.includes(cur)?800:400,background:allowedCurrencies.includes(cur)?'#d1fae5':'#eef2ff'}}>{cur}</button>
              ))}
            </div>
            <div style={{fontSize:12,color:'#888',marginBottom:8}}>Only selected currencies will be available for toggling in transactions/data tabs.</div>
            <div style={{marginTop:10}}><button className="btn primary" onClick={savePrefs}>Save Preferences</button></div>
          </div>
        </div>

        <div className="panel">
          <div className="section-title">üë§ Account Info</div>
          <div className="controls" style={{flexDirection:'column', alignItems:'flex-start'}}>
            <div><strong>Username:</strong> {user}</div>
            <div><strong>Avg Monthly Spending:</strong> ‚Ç™{avgMonthly.toFixed(0)}</div>
            <div><strong>Last Transaction:</strong> {lastTxLabel}</div>
            <div><strong>Data Storage:</strong> User-specific files</div>
          </div>
        </div>

        <div className="panel">
          <div className="section-title">‚ÑπÔ∏è App Information</div>
          <ul style={{marginTop:6}}>
            <li>MoneyTron Multi-User v4.0</li>
            <li>Multi-user support</li>
            <li>Personal categories</li>
            <li>Monthly workflow</li>
            <li>Data visualization</li>
            <li>Export/Import capabilities</li>
            <li>Privacy: All data stored securely on your server.</li>
          </ul>
        </div>
      </div>
    </div>
  );
}


/* ------------------------------- App ------------------------------- */
function App(){
  const [user,setUser]=React.useState(null);
  const [tab,setTab]=React.useState('transactions');
  const [categories,setCategories]=React.useState({});
  const [past,setPast]=React.useState([]);
  const [stage,setStage]=React.useState([]);
  const [settings,setSettings]=React.useState({dateFormat:'YYYY-MM-DD', currency:'ILS'});

  React.useEffect(()=>{ API.logout().catch(()=>{}); },[]);

  function reload(){
    return API.bootstrap().then(d=>{
      setUser(d.user||''); setCategories(asCategories(d.categories)); setPast(asArray(d.past_data)); setStage(asArray(d.current_month));
    }).then(()=> API.getSettings().then(s=>{
      setSettings(s);
      window.settings = s; // Make available globally for currency toggling
    }).catch(()=>{}));
  }
  function doLogin(name){ API.login(name).then(()=>{ setUser(name); setTab('transactions'); return reload(); }).catch(err=>alert('Login failed: '+err.message)); }

  if(!user) return <LoginView onLogin={doLogin}/>;

  function tabBtn(id,label,icon){ return <button className={'tab'+(tab===id?' active':'')} onClick={()=>{ if(tab==='transactions'){ API.saveStage(stage).catch(()=>{}); } setTab(id); }}>{icon} {label}</button>; }
  function onSavedTx(){ reload().then(()=> setTab('data')); }

  return (
    <div className="wrap">
      <h1 className="title">MoneyTron ‚Äî Multi-User Money Tracker</h1>
      <div className="frame">
        <div className="topbar"><div className="pill welcome">Welcome, {user}!</div><button className="ghost btn" onClick={()=>{ API.logout().then(()=>setUser(null)); }}>Switch User</button></div>
        <div className="tabs">
          {tabBtn('transactions','Transactions','üí∞')}
          {tabBtn('summary','Summary','üìä')}
          {tabBtn('data','Data','üìÑ')}
          {tabBtn('categories','Categories','üìö')}
          {tabBtn('statistics','Statistics','üìà')}
        </div>
        {tab==='transactions' && <TransactionsTab rows={stage} setRows={setStage} categories={categories} onSaved={onSavedTx}/>}
        {tab==='data' && <DataTab past={past} categories={categories} onSaved={reload}/>} 
        {tab==='summary' && <SummaryTab past={past} active={tab==='summary'}/>} 
        {tab==='categories' && <CategoriesTab user={user} categories={categories} onSaved={setCategories}/>} 
        {tab==='statistics' && <StatisticsTab past={past} categories={categories}/>} 
      </div>
    </div>
  );
}

ReactDOM.render(<App/>, document.getElementById('root'));
  </script>
</body>
</html>